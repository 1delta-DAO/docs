[{"url":"./","title":"Introduction","level":"1.1","keywords":[],"body":"Welcome to the 1delta Docs! 1delta is a decentralized margin aggregator service that allows users to directly build margin positions using established DEXs and lending protocols. Our objective is to bring a universal aggregator service (comparable to Interactive Brokers in CeFi) to EVMs. Unbound by our own liquidity, we do not have the same limitations that comparable decentralized aggregators experience. Our goal is to partner with and aggregate established protocols in the space and not to directly compete against them. At the moment, crypto traders are limited in the options they have for building leverage while trading. If they choose to use money market protocols for building margin positions they will face a multi-step process that spans multiple dApps, is error-prone, and has low visibility. Existing aggregator/derivatives platforms have been the go-to solution for leveraged trading, however, they come with a steep tradeoff. While centralized players like FTX have failed users by misusing their funds, decentralized platforms like dYdX or GMX are required to provide both lending and trading liquidity often resulting in poor trading performance. Our vision is to bring fully-featured, decentralized aggregator services to EVMs. This includes Single-click margin trading (opening, closing positions, debt- and collateral swaps) Connecting established DEXs with established lending protocols to allow our users to access top-notch trading performance and highly competitive deposit and borrow rates Seamless UX and visibility - easy risk management through risk parameter displays and single-click self-liquidations Full transparency - Users hold the lending protocol balances themselves and can always see and access their raw balances with the lender Lending protocols have been less accessible to traders who are looking for a fully-featured aggregator. With 1delta, we hope to open the door for these traders to take advantage of the strong liquidity and attractive rates on large lending protocols without sacrificing the tools they have come to expect while trading.© 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 06:58:00 "},{"url":"margin-aggregation.html","title":"Margin Aggregation","level":"1.2","keywords":[],"body":"Margin Aggregation Margin Trading In Crypto Margin trading for cryptocurrencies is a financial strategy that enables investors to trade digital assets like Bitcoin, Ethereum, and other altcoins using borrowed funds from a broker or exchange. This approach allows traders to increase their purchasing power and enhance their profit potential by leveraging their existing capital. However, it's essential to remember that margin trading also entails higher risks and can lead to significant losses if the market moves against the trader's position. In cryptocurrency margin trading, investors can access leverage, which is essentially a multiplier that amplifies the trader's capital. For example, if a trader uses 5x leverage, a $1,000 investment would provide them with $5,000 worth of purchasing power in the market. This increased exposure can lead to substantial gains if the market moves in their favor, but it can also magnify losses if the market goes against them. To engage in margin trading, traders are required to deposit an initial margin (or collateral) into a lending protocol. This collateral serves as a guarantee for the borrowed funds and is calculated as a percentage of the total position value. Different lenders may have different margin requirements, and traders should be aware of the specific policies of their chosen platform. When margin trading cryptocurrencies, it's crucial to understand the concept of liquidation. Liquidation occurs when the market moves against a trader's position to the point where their collateral is no longer sufficient to cover their losses. Lenders usually measure this using the health factor. In such a case, the health factor drops below 1 and the wallet will be flagged for liquidation, allowing another actor to close part of the position to recover the borrowed funds. In summary, margin trading for cryptocurrencies is a high-risk, high-reward trading strategy that can lead to significant profits or losses, depending on market movements. It's best suited for experienced traders who have a solid understanding of market dynamics and can effectively manage risk. Margin Trading In DeFi To open margin positions, users can manually loop through the following steps if they want to open an ETH-long position with 4x leverage. Supply initial collateral in ETH worth $1,000 Borrow $800 worth of USDC (80% of %1,000) Swap to ETH and supply again - This will give us another $640 (80% of $800) in borrowing capacity. We will now repeat this cycle until we obtained our target leverage. Borrow $640 (80% of $800), swap an supply Borrow $512 (80% of $640), swap an supply Borrow $409.6 (80% of $512), swap an supply Borrow $327.68 (80% of$409.6), swap an supply Borrow $262.144 (80% of$327.68), swap an supply Borrow $48.576 (the remaining amount to bring the total borrowed funds to $3,000) We see that building this leverage takes 22 transactions to complete as each sub-step in step 3. consists of 3 separate transactions. The following chart summarizes the general procedure. 1) A first USDT deposit is required for taking out a loan; 2) we can borrow WBTC to our wallet; 3) we swap WBTC to USDT on a DEX; 4) we deposit USDT to the lender; we repeat from step 2) until we reach the desired position size. Certainly, this cannot be the long-term solution to DeFi margin trading. 1delta uses unique methods and implementations that allow opening such positions in a maximum of 2 transactions, where the first one is just the initial supply of the collateral. How 1delta Automates The Flow We illustrate the example above using the 1delta protocol. Supply initial collateral in ETH worth $1,000 We use a flash swap and receive $3,000 of ETH and supply We supply the obtained ETH We can now borrow 80% of the $4,000 ($3,200) in USDC the we supplied, we borrow $3,000 We repay the swap pool with the obtained $3,000 in USDC All sub-steps in step 2. happen within the same transaction. As such, there is no more manual looping when trying to build a leveraged position when using lending protocols. The following chart summarizes the interactions with the lender. Illustration of a swap router architecture that can open positions (borrow and supply) with flash swaps or flash loans in only two steps. © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 06:14:50 "},{"url":"guide/overview.html","title":"Guide","level":"1.3","keywords":[],"body":"How To Use 1delta 1delta has a unique approach to margin trading. Our initial version combines the simplicity of a lending protocol interface with well versed swap interfaces that will help you with building any position with the lender. Selecting a Trade To be able to trade on margin, similar to most brokers, you have to deposit collateral first. This can be done through multiple channels - You can either do it directly with the lender (by using their own UI), or just click the \"Deposit\" button in the main panel. If you already have collateral with the lender, this step is skipped. The following overview illustrates the configurations you can set up with the main trade panel. The selections map to the trade types as follows. Single Collateral Position: Swap and deposit or withdraw and swap. Single Debt Position: Borrow and swap or swap and repay. Two Collateral Positions: Swap collateral positions. Two Debt Positions: Swap debt positions. One Collateral and one Debt Positions: Open a margin position (Borrow, swap and supply) or close one (withdraw collateral, swap and repay debt) Lender-Dependent Mechanics Dependent on which lender you want to trade with, the mechanics can vary Via UI Programmatically © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 06:14:50 "},{"url":"guide/frontend.html","title":"Frontend","level":"1.3.1","keywords":[],"body":"How to use 1delta's margin aggregator In this guide, we will outline the process of utilizing the 1delta margin trading implementation to manage lending positions within the AAVE lending protocol. Deposit / Withdraw / Borrow / Repay First-off, we support all basic lending interactions. These can be triggered in multiple ways. Through the main panel (only of you have no deposits) Using the tables undernath the chart with the \"My Wallet\" or \"Markets\" tabs Clicking the button will trigger a quick action panel that allows you to execute any transaction that you could execute with a lending protocol. The quick action panel allows you to execute all direct transactions with the lenders. The left hand side shows the general view, whereas the right hand side shows a configuration where the trader wants to execute a swap before depositing. On input, the bottom of the panel shows a post-transaction indication. The top button row allows you to pick the transactions while the currency dropdowns allow you to pick the currencies for the interaction. In the quick action panel, your wallet balance is always shown at the top, indicated by the wallet icon. If an additional transaction is required before the transfer, the UI will instruct you to either approve spending (in case of deposits, withdrawals and repayments) or approve borrow delegation. After execution, you will see your balance in the \"positions\"-tab in the table: The amount deposited will be display once the deposit transaction is confirmed. Open a margin position With collateral in place, we can now proceed to open a margin position by selecting a borrow currency at the top and a the collateral currency at the bottom. You also have to make sure that the \"open\" option is selected at the top. In our example, we want to sell the maximum amount MWNT possible given our collateral. This value is auto-selected when clicking on the MAX button. As a collateral, we select the currency that we deposited, USDC. The Account panel on the left hand side allows you to simulate the trade on your position by enabling the \"Simulation\" switch at the bottom. On the left hand side, the account panel simulates the user position post-trade. For the given trade on the right hand side, the APR rises by 103 percentage points, the assets and debt rise by about $17.50 and our leverage shoots up to 4.83x. A value can be typed into either panel. After entering a value, a trade will be calculated that leads to the best price. The button will be inactive if you are not allowed to execute the trade (e.g. if your selected trade is too large). Otherwise, a click on the button will trigger your wallet to approve the trade. If any sort of approval is required, the UI will show an approval button instead. Just approve the respective spending or delegation to be able to proceed with the trade. The balanes in the \"Positions\" tab swiftly update and we can see the result after executing the trade selected above: A borrow position with a lender is flagges as a \"Short\" position in 1delta, whereas collateral positions are \"Long\" positions. Swap debt or collateral With 1delta, we can effortlessly exchange our debt or collateral positions in just a single click. The \"Swap\"-option in the main panel enables a sub-selection with \"Collateral\" and \"Debt\" option. Collateral: Executing a collateral swap - a transactions where you can withdraw the top currency, swap it to the bottom currency and deposit it directly. An execution requires you to own the withdrawal currency, meaning that you can only execute a trade where the top amount is lower or equal your existing collateral No restrictions apply to the bottom panel Debt: Executing a debt swap - a transaction that borrows the top currency, swaps it to the bottom one and directly repays it. An execution requires you to hold a debt position in the bottom currency. No restriction to the top currency applies *Collateral- and debt swaps allow you to easily change your exposure in a single trade. In this screenshot, we see the 4.57 USDC obtained after a swap from 10 MNT. Closing a margin position Closing a position (withdraw, swap an repay) is similarly easy. The \"Close\" tab in top button row allows you to execute the following three interactions in one transaction: Withdraw one of your collaterals Trade the currency against another one Repay an outstanding loan You can either pick the maximum collateral amount to withdraw or the maximum debt amount to repay. Our implementation makes sure that no borrow dust will be left. Closing a position allows you to repay a debt position with ease. The simulations on the left hand side shows that our leverage and APR come down to the levels before the position was opened.© 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 06:14:50 "},{"url":"guide/programmatically.html","title":"Programmatically","level":"1.3.2","keywords":[],"body":"How to use 1delta's margin aggregator programmatically 1delta's smart contracts can be used via our Typescript SDK (which is also the one used for our UI). It is using out asset-registry package here. This package contains all lender data that is needed for on-chain actions (e.g. Aave lending tokens, Venus comptrollers etc.). The SDK automatically identifies a lender via the provided enum. Packages pnpm add @1delta/calldata-sdk @1delta/asset-registry // enums for operations import {QuickActionType, MarginTradeType} from \"@1delta/calldata-sdk\" // for direct lending actions import {ComposerDirectLending} from \"@1delta/calldata-sdk\" // margin operations import {ComposerMargin} from \"@1delta/calldata-sdk\" // enums import {Lender} from \"@1delta/asset-registry\" Example usage for depositing to Aave V3 Deposits assets to Aave. The caller needs to ensure that the contract has enough permissions (e.g. token.approve(...)) // --- Configuration for chain --- const chainId = \"10\" const composer = COMPOSER_PROXIES[chainId] // --- Asset and amount --- // Example: deposit 1000 USDC (1e9 = 1000 * 1e6 in smallest units) const input = 1_000_000_000n // 1e9 const depositAsset = { symbol: \"USDC\", name: \"USDC\", address: \"0x0b2c639c533813f4aa9d7837caf62653d097ff85\", chainId } // --- Caller account --- const account = \"0x...\" // --- Lender and action type --- const lender = Lender.AAVE_V3 const action = QuickActionType.Deposit // --- Operation parameters --- const operation = { params: { lender, amount: { currency: depositAsset, amount: input } }, receiver: account, // Caller deposits on their own behalf isAll: false, // Only used for withdraw & repay operations inIsNative: false, // If true, use native asset (ETH) to deposit — operation will wrap ETH outIsNative: false,// If true, unwraps output (e.g. withdraw WETH and unwrap to ETH) composerAddress: composer, permitData: undefined, // No permit used morphoParams: undefined, // No Morpho parameters useOverride: undefined // No custom Aave fork override } // --- Generate calldata and value for transaction --- const { calldata, value } = ComposerDirectLending.composeDirectMoneyMarketAction(operation) Example usage for opening a position on Aave V3 Open a position on Aave. The caller needs to ensure that the contract has enough permissions (e.g. via debtToken.approveDelegation(...)) // Example: Opening a short position on 1 WETH using USDC as collateral const chainId = \"10\" const composer = COMPOSER_PROXIES[chainId] // The caller's account address const account = \"0x...\" // Operation type const marginTradeType = \"Open\" // Intended input amount (in wei) const input = 1_000_000_000_000_000_000n // 1e18 // Assets const assetIn = { symbol: \"WETH\", name: \"WETH\", address: \"0x4200000000000000000000000000000000000006\", chainId } const assetOut = { symbol: \"USDC\", name: \"USDC\", address: \"0x0b2c639c533813f4aa9d7837caf62653d097ff85\", chainId } // Lender to use (refer to the `Lender` enum in asset-registry) const lender = Lender.AAVE_V3 // --- Step 1: Fetch flash liquidity --- // Example return value: // // [ // { // \"id\": 0, // \"name\": \"AAVE_V3\", // \"type\": 2, // \"source\": \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\", // \"fee\": \"5\", // \"availableRaw\": \"7742114549858607894570\", // \"available\": 7742.11454985861 // }, // ... // ] const assetLiquidities = await ( await fetch(`https://margin-data.1delta.io/flashloan-asset/10/0x4200000000000000000000000000000000000006`) ).json() // Pick the first source (ideally choose the lowest-fee source) const flashLoanSource = assetLiquidities[0] // Flash loan fee is used to adjust the quote input const flashFee = BigInt(flashLoanSource.fee) // --- Step 2: Fetch trade --- // With a 5 bps flash fee, we can calculate the adjusted input to borrow exactly 1 WETH: const amendedInput = (input * 10_000n) / (10_000n + flashFee) // Query the swap provider API // Important: Set the receiver to the composer contract const apiBody = { ..., amountIn: amendedInput, receiver: composer } const apiReturn = await ( await fetch(`https://www.quote.odos....`) ).json() // Get calldata from the API (varies by provider) const { calldata, target } = await ( await fetch(`https://www.assemble.odos....`) ).json() // --- Step 3: Prepare trade object for SDK --- const trade: GenericTrade = { tradeType: 0, // exact in inputAmount: { currency: assetIn, amount: amendedInput }, outputAmount: { currency: assetOut, amount: apiReturn.output }, // Output amount is unused in calldata target, // Call target approvalTarget: target, // Usually same as call target, may differ for some aggregators // Set to `true` if `apiBody` does not allow specifying a receiver sweepToReceiver: false, } const externalCall = { target, calldata, value: \"0\", // Default (only used for native asset as input) useSelfbalance: false, callForwarder: FORWARDER } const marginData = { marginTradeType, // STABLE is disabled for most Aave forks irModeIn: AaveInterestMode.VARIABLE, // Unused irModeOut: AaveInterestMode.NONE, lender, morphoParams: undefined, // No Morpho execution permitData: undefined // No permits in this example } // This returns a bytes string for the 1delta composer const composerOperation = ComposerMargin.createMarginFlashLoan({ trade, externalCall, marginData, maxIn: false, // Default (only for non-open operations) maxOut: false, // Default (only for non-open operations) composerOverride: composer, // Composer address flashInfoOverride: flashLoanSource // Flash loan source info }) // Note: Any composer operation can be prepended, e.g.: // // This is the calldata for the composer. // For example, `ComposerDirectLending.composeDirectMoneyMarketAction(...)` // could be used to generate a deposit calldata set, which can then be prepended: // // const depositAndOpen = encodePacked( // [\"bytes\", \"bytes\"], // [depositCalldata, composerOperation] // ) const contractCall = encodeFunctionData({ abi: composerAbi, functionName: \"deltaCompose\", args: [composerOperation] }) © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 06:14:50 "},{"url":"architecture/overview.html","title":"Architecture","level":"1.4","keywords":[],"body":"How is 1delta Built? Generally, lending protocols fall into two categories when trying to compose trades with them. First, we have protocols that allow a user to delegate borrows and withdrawals. This means that a user can approve that another contract can borrow using their collateral or withdraw collateral from their balances directly. This is very similar to the conventional ERC20 approval mechanism that allows this exact mechanic for regular transfers. This architecture allows an external contract to aggregate the position on the user's behalf - meaning that the contract can directly operate on the user's balance. Compound V3, Venus.io, Aave V3 and Morpho Blue are protocols in this category. © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 06:14:50 "},{"url":"lenders/summary.html","title":"Lenders","level":"1.5","keywords":[],"body":"Lenders The following subsections describe the lenders and their specific parameters. Metrics© 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 06:14:50 "},{"url":"lenders/metrics.html","title":"Metrics","level":"1.5.1","keywords":[],"body":"Lending Metrics This section dives into the parameters that lenders use to manage their protocol. The following parameters are used by most of them, including Compound V2 & V3, Aave V1, V2 & V3 and all forks of them. General Parameters All lenders define in one or another form the following parameters: Note that the liquidation collateral factors are usually higher than the borrow collateral factors. Lenders in general allow opening positions at maximum LTV equal to the debt divided by borrow-adjusted collateral. Risk Metrics The collateral parameters and heath factor are calculated in the following manner: An account is flagged for liquidation if the health factor is below 1. Liquidation Price Liquidation prices in return are indicators as to how much a single asset price can move until an account get liquidated. This is done by setting the health factor to one and solving for the USD amount of the desired asset. The liquidation price for a long asset (indexed with k) can be calculated via assuming that the USD amount of asset k is dependent on all other given parameters as follows: Dividing the last amount by the collateral amount in question yields the liquidation price for a long position in asset k: For a short asset, we solve for the debt USD amount of asset k: Dividing the last amount by the debt amount in question yields the liquidation price for the short position in asset k: Same-asset positions Generally, the liquidation price in a specific asset assumes that the prices of all other assets are frozen. Certain lenders, however, allow borrowing and collateralizing the same asset at the same time. These lenders are Aave V3, Lendle, Compound V2 and all respective forks. For this case, we cannot use the conventional liquidation price, since for a long position with a borrow position of less than the collateral, the liquidation risk in this specific asset is non-existent. Generally, there are two cases for liquidation prices of asset k, in both we calculate the net exposure in the asset and apply it to the liquidation price: The collateral in the asset is higher than the debt Long liquidation price: For this case, we have to net the exposure in the single asset. In this case, we reduce all amounts by the debt amounts. Short liquidation price: Infinity, since there is no liquidation risk. The collateral in the asset is lower than the debt Long liquidation price: Zero, there is no long liquidation risk in this asset. Short liquidation price: For this case, we also have to net the exposure in the single asset. This means that we use the conventional liquidation price and reduce all amounts by the respective collatreral amount. Leverage The leverage is a good measure for exposure. It can be provided on an overall basis or just in the context of a single asset. The overall leverage is just the quotient of collateral and debt. The maximum leverage for a single asset is calculated using the collateral factor of the collateral asset. It is important to note that in this case, the maximum leverage for a single asset is dependent on the collateral assetn and its borrow collateral factor only. As such, measuring the leverage for the short asset only depends on the collateral used (in this case, it is usually a stablecoin). Certain lenders like Euler Finance use borrow factors to weight borrow positions differently, too. © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 06:14:50 "},{"url":"contract-addresses/summary.html","title":"Contract Addresses","level":"1.6","keywords":[],"body":"Contract Addresses These are the deployment addresses for the 1delta composer smart contracts. Composer contract Chain Address ARBITRUM_ONE 0x05f3f58716a88A52493Be45aA0871c55b3748f18 OP_MAINNET 0xCDef0A216fcEF809258aA4f341dB1A5aB296ea72 POLYGON_MAINNET 0xFd245e732b40b6BF2038e42b476bD06580585326 BASE 0xB7ea94340e65CC68d1274aE483dfBE593fD6f21e SONIC_MAINNET 0x8E24CfC19c6C00c524353CB8816f5f1c2F33c201 HEMI_NETWORK 0x79f4061BF049c5c6CAC6bfe2415c2460815F4ac7 TAIKO_ALETHIA 0x594cE4B82A81930cC637f1A59afdFb0D70054232 METIS_ANDROMEDA_MAINNET 0xCe434378adacC51d54312c872113D687Ac19B516 GNOSIS 0xcb6eb8df68153cebf60e1872273ef52075a5c297 AVALANCHE_C_CHAIN 0x8E24CfC19c6C00c524353CB8816f5f1c2F33c201 MODE 0x8E24CfC19c6C00c524353CB8816f5f1c2F33c201 SCROLL 0x8E24CfC19c6C00c524353CB8816f5f1c2F33c201 CORE_BLOCKCHAIN_MAINNET 0x816EBC5cb8A5651C902Cb06659907A93E574Db0B FANTOM_OPERA 0x816EBC5cb8A5651C902Cb06659907A93E574Db0B BNB_SMART_CHAIN_MAINNET 0x816EBC5cb8A5651C902Cb06659907A93E574Db0B MANTLE 0x5c019a146758287c614fe654caec1ba1caf05f4e LINEA 0x816EBC5cb8A5651C902Cb06659907A93E574Db0B BLAST 0x816EBC5cb8A5651C902Cb06659907A93E574Db0B KAIA_MAINNET 0x8E24CfC19c6C00c524353CB8816f5f1c2F33c201 SONEIUM 0x8E24CfC19c6C00c524353CB8816f5f1c2F33c201 HYPEREVM 0xcb6eb8df68153cebf60e1872273ef52075a5c297 UNICHAIN 0xcB6Eb8df68153cebF60E1872273Ef52075a5C297 KATANA 0x8E24CfC19c6C00c524353CB8816f5f1c2F33c201 Call forwarder contract Chain Address ALL CHAINS 0xfCa1154C643C32638AEe9a43eeE7f377f515c801 © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 06:14:50 "},{"url":"api/summary.html","title":"Contract API","level":"1.7","keywords":[],"body":"Contract Interfaces The following subsections describe the smart contract api for both the brokerage/aggregation contract. Entrypoint Operations Transfers External Call Lending Aave Compound V3 Flash Loans Margin© 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 08:31:06 "},{"url":"api/entrypoint.html","title":"Entrypoint","level":"1.7.1","keywords":[],"body":"Contract Entry Point The 1delta protocol provides a single unified entry point for executing DeFi operations through our composer contracts. Main Entry Point: deltaCompose(bytes) Function Signature function deltaCompose(bytes calldata data) external payable The deltaCompose function is the primary interface for executing batched operations. It accepts compact, byte-encoded operation sequences that are processed atomically within a single transaction. Key Characteristics Atomic Execution: All operations in a batch either succeed together or fail together Gas Efficient: Compact encoding minimizes transaction costs Composable: Operations can be chained and nested arbitrarily Stateless: Other than the approval and entry flags, the contract is stateless Payable: Can receive native tokens for operations requiring them Operation Encoding Structure Reference Enums For enum definitions used in the examples below, see: TransferIds and SweepType Composer Commands Operations are categorized using the following command identifiers: enum ComposerCommands { SWAPS; // swap paths EXT_CALL; // external calls (`deltaForwardCompose`) EXT_TRY_CALL; // external call with fallback (callForwarder only) LENDING; // any lending operation (deposit, borrow, withdraw, repay) TRANSFERS; // pulling, sending and approving PERMIT; // execute token or lender permit FLASH_LOAN; // execute flash loans on common targets ERC4626; // vault operations GEN_2025_SINGELTONS; // balancer V3 and Uniswap V4 operations BRIDGING; // bridge execution (callForwarder only) } Encoding Format All operations follow a consistent encoding pattern: [command: uint8][operation-specific data: bytes] Composable Operation Flow Sequential Execution Operations are executed in the order they appear in the encoded data. operation 1 -> operation 2 -> ... Nested Operations Complex operations can contain sub-operations, enabling DeFi strategies: Flash Loan Operation { Inner Operations: [ Swap Operation, Lending Operation, Transfer Operation ] } Simple Example This example shows how to encode a simple transfer operation. The operation structure follows the standard pattern of [command: uint8][operation-specific data: bytes]. Operation Data Structure Offset Length (bytes) Description Value Example 0 1 Command ID 0x40 (TRANSFERS) 1 1 Operation ID 1 (SWEEP) 2 20 Token address 0xA0b8... 22 20 Receiver address 0xd8dA... 42 1 Sweep type 1 (AMOUNT) 43 16 Amount (uint128) 1000000 Solidity Example import {ComposerCommands, TransferIds} from \"@1delta-contracts/enums/DeltaEnums.sol\"; import {SweepType} from \"@1delta-contracts/enums/MiscEnums.sol\"; function transferTokens() external { address token = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; address receiver = 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045; uint256 amount = 1000000; // Encode the transfer operation directly bytes memory transferOp = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), // 0x40 - Transfer command uint8(TransferIds.SWEEP), // 1 - SWEEP operation ID token, // Token address receiver, // Receiver address uint8(SweepType.AMOUNT), // 1 - AMOUNT sweep type uint128(amount) // Amount to transfer ); composer.deltaCompose(transferOp); } TypeScript Example import { encodePacked } from \"viem\" function encodeTransfer(): `0x${string}` { const TRANSFERS = 0x40 // ComposerCommands.TRANSFERS const SWEEP = 1 // TransferIds.SWEEP const AMOUNT = 1 // SweepType.AMOUNT const tokenAddress = \"0xA0b86a33E6441e88b5f6f1FcD8c7d4d0d9e4b8C3\" const receiver = \"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\" const amount = 1000000 return encodePacked([\"uint8\", \"uint8\", \"address\", \"address\", \"uint8\", \"uint128\"], [TRANSFERS, SWEEP, tokenAddress, receiver, AMOUNT, amount]) } Development Note In practice, operations are most often created using helper libraries to avoid manual encoding: Solidity: Use CalldataLib functions like encodeSweep() for complex operations TypeScript: Use the 1delta SDK which provides high-level functions for operation creation Manual encoding is shown to demonstrate the underlying structure. © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 09:37:56 "},{"url":"api/operations.html","title":"Operations","level":"1.7.2","keywords":[],"body":"Operation Encoding Operations are produced by encoding them into compact byte arrays that follow a consistent structure. The 1delta protocol supports multiple operation categories, each with specific encoding patterns and use cases. Operation Categories 1. Transfer Operations (TRANSFERS = 0x40) Transfer operations handle token movements, approvals, and wrapping operations. Key Features: Token transfers between addresses Token approvals for spending Native token wrapping/unwrapping Permit2 operations Common Use Cases: Moving tokens into position for lending Transferring profits to user Setting up approvals for protocols Wrapping/unwrapping native tokens 2. Swap Operations (SWAPS = 0x10) Swap operations enable trading across multiple DEX protocols with advanced routing. Key Features: DEX swaps across multiple protocols Multi-hop swap routing Flash swap callbacks Slippage protection Supported Protocols: Uniswap V2/V3 Balancer V2/V3 Curve Dodo WooFi GMX And more... 3. Lending Operations (LENDING = 0x30) Lending operations provide access to various lending protocols through a unified interface. Key Features: Deposit/withdraw collateral Borrow/repay debt Cross-protocol operations Position management Supported Protocols: Aave V2/V3 Compound V2/V3 Morpho Blue And more... 4. Flash Loan Operations (FLASH_LOAN = 0x60) Flash loan operations enable instant borrowing without collateral, requiring repayment within the same transaction. Key Features: Instant borrowing without collateral Arbitrage opportunities Liquidation protection Complex DeFi strategies Supported Providers: Morpho Blue Aave V2/V3 Balancer V2 5. External Calls (EXT_CALL = 0x20, EXT_TRY_CALL = 0x21) External call operations enable integration with arbitrary smart contracts. Key Features: Integration with external protocols Fallback mechanisms (EXT_TRY_CALL) Complex interaction patterns Custom contract calls 6. ERC4626 Vault Operations (ERC4626 = 0x70) ERC4626 operations provide standardized access to yield vaults. Key Features: Deposit to yield vaults Withdraw from vaults Share management Standardized vault interface 7. Modern DEX Operations (GEN_2025_SINGELTONS = 0x80) Modern DEX operations support Balancer V3 and Uniswap V4 features. Key Features: Balancer V3 operations Uniswap V4 operations Advanced liquidity management Singleton contract patterns 8. Bridge Operations (BRIDGING = 0x90) Bridge operations enable cross-chain transfers and interactions (only call forwarder) Key Features: Cross-chain transfers Bridge protocol integration Across/Stargate integration Encoding Structure All operations follow a consistent encoding pattern: [command: uint8][operation-specific data: bytes] Command Byte Values enum ComposerCommands { SWAPS = 0x10, // DEX swap operations EXT_CALL = 0x20, // External contract calls EXT_TRY_CALL = 0x21, // External calls with fallback LENDING = 0x30, // Lending protocol operations TRANSFERS = 0x40, // Token transfers and approvals PERMIT = 0x50, // Permit operations FLASH_LOAN = 0x60, // Flash loan operations ERC4626 = 0x70, // ERC4626 vault operations GEN_2025_SINGELTONS = 0x80,// Modern DEX operations BRIDGING = 0x90 // Cross-chain bridge operations } © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 08:47:29 "},{"url":"api/transfers.html","title":"Transfers","level":"1.7.2.1","keywords":[],"body":"Transfers Lead type: ComposerCommands.TRANSFERS. The sub types are defined by the following enum: TransferIds Enum Value Name Description 0 TRANSFER_FROM Pull funds from caller 1 SWEEP Send funds from this contract 3 UNWRAP_WNATIVE Unwrap native currency 4 PERMIT2_TRANSFER_FROM Permit2 transfer 5 APPROVE Approve target SweepType Enum Value Name Description 0 VALIDATE Check if balanceOf(address(this)) >= amount, if true transfer it, if not revert 1 AMOUNT Transfer the amount without validation To encode an operation, the caller has to append abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.[Operation]), ...params ); to the array of composer commands. Transfer From Operation Pull funds from the caller to a receiver address. Parameters Offset Length (bytes) Description 0 20 asset address 20 20 receiver address 40 16 amount uint128 Notes If amount is 0, we pull asset.balanceOf(caller). Encoding Example // Solidity bytes memory transferFromOp = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.TRANSFER_FROM), assetAddress, receiverAddress, uint128(amount) ); // TypeScript const transferFromOp = encodePacked( [\"uint8\", \"uint8\", \"address\", \"address\", \"uint128\"], [TRANSFERS_COMMAND, TransferIds.TRANSFER_FROM, assetAddress, receiverAddress, amount] ) Sweep Operation Pull funds from this contract to a provided address. Parameters Offset Length (bytes) Description 0 20 asset address 20 20 receiver address 40 1 sweepType SweepType 41 16 amount uint128 Enums Used SweepType Enum - Validation mode for the sweep operation Notes Note that asset can be the zero address for native currency. Encoding Examples // Solidity - Basic sweep bytes memory sweepOp = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.SWEEP), assetAddress, receiverAddress, uint8(SweepType.AMOUNT), uint128(amount) ); // TypeScript - Basic sweep const sweepOp = encodePacked( [\"uint8\", \"uint8\", \"address\", \"address\", \"uint8\", \"uint128\"], [TRANSFERS_COMMAND, TransferIds.SWEEP, assetAddress, receiverAddress, SweepType.AMOUNT, amount] ) Sweeping Full Balance To sweep the entire balance of an asset without knowing the exact amount, set amount = 0 and use SweepType.VALIDATE: // Sweep entire token balance function encodeSweepFullBalance(asset: string, receiver: string) { return abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.SWEEP), asset, receiver, uint8(SweepType.VALIDATE), // fetch actual balance and validate uint128(0) // amount = 0 triggers balanceOf lookup ) } This works because: SweepType.VALIDATE fetches the actual balance using balanceOf(address(this)) amount = 0 ensures the validation always passes (balance >= 0) The full balance is transferred to the receiver Wrapping Native Currency To wrap the native currency to wrapped native, you can just use asset=address(0),receiver=wrappedNativeAddress. // Wrap native currency using SWEEP operation function encodeWrap(amount: bigint, wrapTarget: string) { return abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.SWEEP), address(0), // signals native asset wrapTarget, // wrapped native contract address uint8(SweepType.AMOUNT), uint128(amount) ) } This works because: asset = address(0) tells the system to handle native currency The wrapped native contract's receive() or fallback() function automatically wraps incoming native currency Unwrap WNative Operation Unwrap native asset and transfer if needed. Parameters Offset Length (bytes) Description 0 20 wrappedNativeAddress address 20 20 receiver address 40 1 sweepType SweepType 41 16 amount uint128 Enums Used SweepType Enum - Validation mode for the unwrap operation Notes Note that we do not hard-code the wrapped native address as some chains have duplicate wnative implementations. Encoding Example // Solidity bytes memory unwrapOp = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.UNWRAP_WNATIVE), wrappedNativeAddress, receiverAddress, uint8(SweepType.AMOUNT), uint128(amount) ); // TypeScript const unwrapOp = encodePacked( [\"uint8\", \"uint8\", \"address\", \"address\", \"uint8\", \"uint128\"], [TRANSFERS_COMMAND, TransferIds.UNWRAP_WNATIVE, wrappedNativeAddress, receiverAddress, SweepType.AMOUNT, amount] ) Permit2 Transfer From Operation Execute a transfer via permit2. We only support the canonical Uniswap permit2 at address 0x000000000022D473030F116dDEE9F6B43aC78BA3. Parameters Offset Length (bytes) Description 0 20 asset address 20 20 receiver address 40 16 amount uint128 Notes If amount is 0, we pull asset.balanceOf(caller). Encoding Example // Solidity bytes memory permit2TransferOp = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.PERMIT2_TRANSFER_FROM), assetAddress, receiverAddress, uint128(amount) ); // TypeScript const permit2TransferOp = encodePacked( [\"uint8\", \"uint8\", \"address\", \"address\", \"uint128\"], [TRANSFERS_COMMAND, TransferIds.PERMIT2_TRANSFER_FROM, assetAddress, receiverAddress, amount] ) Approve Operation Approve an asset - typically for a lender operation or external call. Parameters Offset Length (bytes) Description 0 20 token address 20 20 target address Notes ERC20-Approve the target via token, always uses infinite approve, the approval is stored and skipped if already done in the past. Encoding Example // Solidity bytes memory approveOp = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.APPROVE), tokenAddress, targetAddress ); // TypeScript const approveOp = encodePacked([\"uint8\", \"uint8\", \"address\", \"address\"], [TRANSFERS_COMMAND, TransferIds.APPROVE, tokenAddress, targetAddress]) © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 09:36:54 "},{"url":"api/external-call.html","title":"External Call","level":"1.7.2.2","keywords":[],"body":"External calls in the composer contracts To provide the caller with full flexibility, we allow them to call any arbitrary target indirectly via a callForwarder contract that has the onl entrypoint function deltaForwardCompose(bytes) The composer contract can call arbitrary targets with that fixed selector, whereas the callForwarder can call any target whith any selector (there are exceptions like the permit2 address and transferFrom selector) To facilitate an external call with data on target, one needs to pull caller funds (directly to callForwarder) execute ComposerCommands.EXT_CALL with the parameters on the callForwarder on the composer where the operation forwarded is also ComposerCommands.EXT_CALL with the provided data and target While this approach seems to be inefficient, it is necessary to prevent malicious callers to execute bad calldata on the composer contract (e.g. trying to execute transferFrom from a prior caller that approved the composer) The operation parameters for the composer are given as follows. Offset Length (bytes) Description 0 20 target address 20 16 value uint128 36 20 dataLength address 38 dataLength data address value is the native currency amount to attach. The value has a high bit that indicates whether to use the selfbalance To encode an operation, te caller has to append this data to the call. abi.encodePacked( uint8(ComposerCommands.EXT_CALL), target, uint128(value), uint16(data.length), data ); Note that for arbitrary calls, we need to use the callForwarder, then it looks like this. // this is the default forwarder address address callForwarderAddress = 0xfCa1154C643C32638AEe9a43eeE7f377f515c801; // create the call for the forwarder // the target can e.g. be the 1inch aggregation router bytes memory callForwarderCall = abi.encodePacked( uint8(ComposerCommands.EXT_CALL), target, uint128(value), uint16(data.length), data ); // prepare the composer call bytes memory composerCall = abi.encodePacked( uint8(ComposerCommands.EXT_CALL), callForwarderAddress, // it is important to use the forwarder on the composer level uint128(value), uint16(callForwarderCall.length), callForwarderCall ); It is important to note that the call for the forwarder needs to be prepared. Example: 1inch meta-aggregation Hrere we illustrate the creation of the call for a swap from USDC to WETH using 1inch. The following steps need to be executed: callForwarder calls create approve if needed create external call to router sweep funds to receiver and check slippage if desired composer calls transfer funds from caller to callForwarder execute external call through callForwarder The reason why we use the forwarder is to peserve the statelessness of the composer while still allowing calls to any target without requiring whiltelists. uint256 swapAmount = 4000.0e6; // this is the default forwarder address address callForwarderAddress = 0xfCa1154C643C32638AEe9a43eeE7f377f515c801; // create the call for the forwarder // the target can e.g. be the 1inch aggregation router bytes memory callForwarderCall = abi.encodePacked( uint8(ComposerCommands.EXT_CALL), address(oneInchAggregationRouter), uint128(0), // ERC20 has no value uint16(data.length), data ); // we need to approve the 1inch router on the callForwarder level // note that the approval is skipped if it was already done in the past bytes memory approve1inch = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.APPROVE), address(USDC), address(oneInchAggregationRouter) ); // expect to receive 1 WETH // revert if we receive less uint256 amountExpected = 1.0e18; // in case the aggregators does not transfer directly to the user bytes memory sweepAndCheckSlippage = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.SWEEP), address(WETH), address(receiver), // this is the receiver of the WETH uint8(SweepType.AMOUNT), amountExpected ); // combine the operations callForwarderCall = abi.encodePacked( approve1inch, callForwarderCall, sweepAndCheckSlippage ); // prepare the composer call // this executes callForwader.deltaForwardCompose(callForwarderCall) bytes memory composerCall = abi.encodePacked( uint8(ComposerCommands.EXT_CALL), callForwarderAddress, // it is important to use the forwarder on the composer level uint128(value), uint16(callForwarderCall.length), callForwarderCall ); // we need to make sure that teh callForwarder receives the funds directly bytes memory transferToForwarder = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.TRANSFER_FROM), address(USDC), callForwarderAddress, uint128(swapAmount) ); // combine the call to the composer composerCall = abi.encodePacked( transferToForwarder, composerCall ); // execute the operations composer.deltaCompose(composerCall); © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 09:38:59 "},{"url":"api/lending.html","title":"Lending","level":"1.7.2.3","keywords":[],"body":"Lending Lead type: ComposerCommands.LENDING. The sub types are dcefined by the following enum: enum LenderOps { DEPOSIT = 0, // deposit (collateral) BORROW = 1, // borrow from lender REPAY = 2, // repay to lender WITHDRAW = 3, // withdraw from lender DEPOSIT_LENDING_TOKEN = 4, // deposit lending token (e.g. for Morpho Blue) WITHDRAW_LENDING_TOKEN = 5, // withdraw lending token (e.g. for Morpho Blue) } to the array of composer commands. We ecode lender types as follows: enum LenderIds { UP_TO_AAVE_V3 = 1000, UP_TO_AAVE_V2 = 2000, UP_TO_COMPOUND_V3 = 3000, UP_TO_COMPOUND_V2 = 4000, UP_TO_MORPHO = 5000, } To encode an operation, te caller has to append this data to the call. abi.encodePacked( uint8(ComposerCommands.LENDING), uint8(TransferIds.[Operation]), uint16(LenderIds.[Lender]) ...params ) Specific lenders Aave V2 & V3 & forks Compound V3 markets© 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 09:39:03 "},{"url":"api/lending/aave.html","title":"Aave","level":"1.7.2.3.1","keywords":[],"body":"Aave V2 & V3 & Forks Aave V2 and V3 behave very similar for all operations. The caller only needs to dustinguish them via LenderIds, the rest is handled by the contract logic. Deposit Deposit the underlying to the lender for the given pool. If amount=0, we use the contract balance via underlying.balanceOf(address(this)). This is recommended when executing this operation after a swap. Offset Length (bytes) Description 0 20 underlying address 20 16 amount uint128 36 20 receiver address 76 20 pool address Withdraw Withdraw for the lender. Note that this requires that the caller approved the composer to spend aToken on their behalf. If amount=0xffffffffffffffffffffffffffff, we read underlying.balanceOf(callerAddress) and withdraw the full balance without leaving dust. Offset Length (bytes) Description 0 20 underlying address 20 16 amount uint128 36 20 receiver address 76 20 aToken address 96 20 pool address Borrow Borrow from the lender. The prequisite is that the caller approved the composer contract to borrow on thei behalf via debtToken.approveDelegation(...). It is important that the mode is provided here, most Aave forks only support mode=2 (variable). If the selector withotu mode is used, one needs to set mode=0. Offset Length (bytes) Description 0 20 underlying address 20 16 amount uint128 36 20 receiver address 76 1 mode uint8 77 20 pool address Repay Repay to the lender. In this case, use amount=0 to repay underlying.balanceOf(address(this)), the contract balance, if amount=0xffffffffffffffffffffffffffff, repay the minimum of the contract balance and the caller debt. Offset Length (bytes) Description 0 20 underlying address 20 16 amount uint128 36 20 receiver address 76 1 mode uint8 77 20 debtToken address 97 20 pool address © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 06:57:50 "},{"url":"api/lending/compound-v3.html","title":"Compound V3","level":"1.7.2.3.2","keywords":[],"body":"Compound V3 markets All Compound V3 markets behave the same way. The market is specified by the comet parameter. The markets are isolated from each other and only one currency is borrowable. Deposit Deposit the underlying to the lender for the given pool. If amount=0, we use the contract balance via underlying.balanceOf(address(this)). This is recommended when executing this operation after a swap. Offset Length (bytes) Description 0 20 underlying address 20 16 amount uint128 36 20 receiver address 76 20 comet address Withdraw Withdraw for the lender. Note that this requires that the caller approved the composer to via comet.allow(...). If amount=0xffffffffffffffffffffffffffff, we read underlying.balanceOf(callerAddress) and withdraw the full balance without leaving dust. Offset Length (bytes) Description 0 20 underlying address 20 16 amount uint128 36 20 receiver address 76 1 isBase uint8 77 20 comet address You need to provide the isBase flag if you want to withdraw the base asset. The reason for this is that Compound V3 has diffrerent ways to compute balances for the base asset. Borrow Borrow from the lender. The prequisite is that the caller approved the composer contract to borrow on their behalf via comet.allow(...). Offset Length (bytes) Description 0 20 underlying address 20 16 amount uint128 36 20 receiver address 76 20 comet address Repay Repay to the lender. In this case, use amount=0 to repay underlying.balanceOf(address(this)), the contract balance, if amount=0xffffffffffffffffffffffffffff, repay the minimum of the contract balance and the caller debt. Offset Length (bytes) Description 0 20 underlying address 20 16 amount uint128 36 20 receiver address 76 20 comet address © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 06:14:50 "},{"url":"api/flash-loan.html","title":"Flash Loan","level":"1.7.2.4","keywords":[],"body":"Flash Loans Lead type: ComposerCommands.FLASH_LOAN. The sub types are dcefined by the following enum: enum FlashLoanIds { MORPHO = 0, // this is Morpho Blue BALANCER_V2 = 1, // covers the fork Swaap, too AAVE_V3 = 2, // covers many forks AAVE_V2 = 3, // covers many forks } to the array of composer commands. To encode an operation, te caller has to append this data to the call. abi.encodePacked( uint8(ComposerCommands.FLASH_LOAN), uint8(FlashLoanIds.[FlashLoanProvider]), ...params ) Alternative sources can be Uniswap V4 and Balancer V3. Thsese are triggered via the lead type: ComposerCommands.GEN_2025_SINGELTONS. We elaborate on these later. Specific lenders Aave V2 & V3 & forks Singletons© 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 06:58:00 "},{"url":"api/flash-loan/standardized-interface.html","title":"Standardized Interface","level":"1.7.2.4.1","keywords":[],"body":"Standardized flash loan interface. While flash loans implementations are nearly all the same, the explicit usage and interface vary. In this section we cover the flash laons provided by Balancer V2 and Swaap Aave V2 & V3 Morpho Blue Flash loan The following parameters need to be provided for Aave V2, V3 and Morpho Blue: Offset Length (bytes) Description 0 20 asset address 20 20 pool address 40 16 amount uint128 56 2 paramsLength + 1 uint16 58 1 poolId uint8 59 + paramsLength paramsLength params bytes (packed) The way how the end data is structured is based on the validation logic. Since flash loans use callbacks, we need poolId to validate that the callback was triggred by a trusted Aave or Morpho pool. params is a packed set of composer operations. Note that The composer re-enters itself here The caller address is forwarderd from the origninal call source The validation logic is hard-coded, as such, only a limited set of pools are allowed to be called. Some flash loan sources are DEXs - e.g. Balancer V2 - this means that swaps thorugh it are not possible any longer as the DEX is typically re-entrancy protected. This also applies to Uniswap V4. They can be used as follows for e.g. looping USDC in a Aaave type lender. // select 1M USDC uint128 amount = uint128(1000000.0e6); bytes memory innerOperation = abi.encodePacked( encodeDeposit(...,USDC, amount,...) // deposit USDC amount to lender encodeBorrow(...,USDC, amount,...) // borrow USDC amount from lender ) bytes memory operation = abi.encodePacked( uint8(ComposerCommands.FLASH_LOAN), // then just continue the next one uint8(FlashLoanIds.MORPHO_BLUE), USDC, MORPHO_BLUE_ADDRESS amount, uint16(innerOperation.length + 1), uint8(0), // the original morpho blue has poolId 0. innerOperation ) composer.deltaCompose(operation); © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 06:58:00 "},{"url":"api/margin/general.html","title":"Margin","level":"1.7.2.5","keywords":[],"body":"General Margin Operations We provide a sketch to execute general margin operations here. The Flow In general, assuming the caller has existing balances with the lender, there aer two major steps, the flash loan itself and the inner call We execute the flashLoan call with currency X and amount x Execute the Inner Calls swap x to currency Y and amount y put y into a lender to increase the credit line (e.g. deposit or repay) pull x from the lender (e.g. withdraw or borrow) Repay the flash loan with funds x Considerations Lending operations that take funds need approvals (see Transfers section for that) and sometimes need to unwrap the flash loaned amount to native. Lending operations that pull funds on the user's behalf need to be permissioned by the user. Operations Leverage Close Collateral Swap Debt Swap Postion Migration© 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 06:58:00 "},{"url":"api/margin/leverage.html","title":"Leverage","level":"1.7.2.5.1","keywords":[],"body":"Leveraging (Borrow & Deposit) This guide covers leveraging operations, which allow users to increase their position size by borrowing against deposited collateral and reinvesting the borrowed funds. Overview Leveraging involves borrowing assets against your collateral, swapping the borrowed assets for more collateral, then depositing the additional collateral. This amplifies your exposure to the collateral asset while maintaining efficient capital usage through flash loans. The entire operation is atomic, ensuring that either all steps succeed or the transaction reverts completely. Example Scenario We'll demonstrate creating a leveraged WETH position on Aave V3 using borrowed USDC. The process involves: Flash loan USDC Swap USDC to WETH via 1inch Deposit user's ETH + swapped WETH as collateral Borrow USDC to repay flash loan Starting Capital: User contribution: 1 ETH Target Position: Total collateral: 3 WETH (1 from user + 2 from leverage) Debt: 8,000 USDC We'll use Morpho Blue as our flash loan provider for optimal rates. Constants // User's initial contribution uint256 USER_AMOUNT = 1.0e18; // Default forwarder address address CALL_FORWARDER = 0xfCa1154C643C32638AEe9a43eeE7f377f515c801; // 1Delta composer IComposer composer = IComposer(0x...); // Aave V3 pool address address AAVE_V3_POOL = address(0x...); // 1inch aggregation router address oneInchAggregationRouter = address(0x111...); // Morpho Blue flash loan source address MORPHO_BLUE = address(0xbbb...); // WETH contract address address WETH = address(0xC02...); Operation Sequence 1. Pull User Funds First, we transfer the user's ETH and efficiently convert it to WETH in a single operation. bytes memory transferIn = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.TRANSFER_FROM), address(0), // Transfer ETH (address(0)) address(WETH), // Convert to WETH directly uint128(USER_AMOUNT) // Amount: 1 ETH ); 2. Deposit Total Collateral We deposit all available WETH (user's contribution plus swapped amount) into Aave V3. Setting amount to 0 deposits the contract's entire WETH balance. Important: Ensure all required approvals are granted beforehand (see Approvals section). bytes memory deposit = abi.encodePacked( uint8(ComposerCommands.LENDING), uint8(LenderOps.DEPOSIT), uint16(LenderIds.UP_TO_AAVE_V3 - 1), // Aave V3 identifier address(WETH), // Asset to deposit uint128(0), // 0 = deposit entire balance address(user), // Deposit recipient address(AAVE_V3_POOL) // Aave V3 pool address ); 3. Borrow Against Collateral We borrow exactly the flash loan repayment amount (plus any fees) in USDC. The borrowed funds go directly to the forwarder to minimize transfers. bytes memory borrow = abi.encodePacked( uint8(ComposerCommands.LENDING), uint8(LenderOps.BORROW), uint16(LenderIds.UP_TO_AAVE_V3 - 1), // Aave V3 identifier address(USDC), // Asset to borrow uint128(8000.0e6), // Flash loan repayment amount address(CALL_FORWARDER), // Send directly to forwarder uint8(2), // Variable rate mode address(AAVE_V3_POOL) // Aave V3 pool address ); 4. Approvals Required approvals for the operation to succeed: // Approve Aave V3 pool to spend WETH for collateral deposit bytes memory approvePool = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.APPROVE), address(WETH), // Asset to approve address(AAVE_V3_POOL) // Spender ); // Approve Morpho Blue to pull USDC for flash loan repayment bytes memory approveMorpho = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.APPROVE), address(USDC), // Asset to approve address(MORPHO_BLUE) // Spender ); 5. Meta Swap Configuration The swap operation converts flash-loaned USDC to WETH for additional collateral. Since funds are already at the forwarder from the flash loan, we skip manual transfers. // Configure the forwarder call to 1inch bytes memory callForwarderCall = abi.encodePacked( uint8(ComposerCommands.EXT_CALL), address(oneInchAggregationRouter), // Target contract uint128(0), // No ETH value for ERC20 swap uint16(data.length), // Call data length data // 1inch swap call data ); // Approve 1inch to spend USDC bytes memory approve1inch = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.APPROVE), address(USDC), // Asset to approve address(oneInchAggregationRouter) // Spender ); // Verify minimum output and transfer to composer uint256 amountExpected = 2.0e18; // Expected 2 WETH from swap bytes memory sweepAndCheckSlippage = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.SWEEP), address(WETH), // Asset to sweep address(composer), // Send to composer for deposit uint8(SweepType.AMOUNT), amountExpected // Minimum required amount ); // Combine forwarder operations callForwarderCall = abi.encodePacked( approve1inch, callForwarderCall, sweepAndCheckSlippage ); // Create meta swap call through forwarder bytes memory metaSwap = abi.encodePacked( uint8(ComposerCommands.EXT_CALL), address(CALL_FORWARDER), // Forwarder contract uint128(0), // No ETH value uint16(callForwarderCall.length), // Call data length callForwarderCall // Forwarder operations ); Complete Operation Assembly Putting it all together with the flash loan wrapper: uint128 flashLoanAmount = uint128(8000.0e6); // USDC amount to flash loan // Inner operations executed within flash loan callback bytes memory innerOperation = abi.encodePacked( metaSwap, // Swap flash-loaned USDC to WETH deposit, // Deposit all WETH as collateral borrow // Borrow USDC to repay flash loan ); // Flash loan wrapper bytes memory flashLoan = abi.encodePacked( uint8(ComposerCommands.FLASH_LOAN), uint8(FlashLoanIds.MORPHO_BLUE), address(USDC), // Flash loan asset address(MORPHO_BLUE), // Flash loan provider flashLoanAmount, // Flash loan amount uint16(innerOperation.length + 1), // Callback data length uint8(0), // Morpho Blue pool ID innerOperation // Operations to execute ); // Complete operation sequence bytes memory composerOps = abi.encodePacked( transferIn, // Pull user's ETH and convert to WETH approvePool, // Pre-approve Aave pool for WETH approveMorpho, // Pre-approve Morpho Blue for USDC flashLoan // Execute flash loan with inner operations ); // Execute the complete leverage operation composer.deltaCompose{value: USER_AMOUNT}(composerOps); Key Considerations Debt Delegation: The operation requires prior debt delegation approval for borrowing: IDebtToken(AAVE_V3_USDC_V_TOKEN).approveDelegation(composer, type(uint256).max) Flash Loan Fees: The borrow amount must account for any flash loan fees to ensure complete repayment. Slippage Protection: The sweep operation with SweepType.AMOUNT ensures you receive sufficient WETH to make the leverage worthwhile. Efficient ETH Handling: The TRANSFER_FROM operation with WETH as the target efficiently converts ETH to WETH without separate wrapping steps. Gas Optimization Strategies: User fund transfers and approvals are placed outside the flash loan callback Direct transfers to the forwarder eliminate unnecessary token movements Maximum approvals reduce future transaction costs Risk Management: The entire operation is atomic - partial execution is impossible Minimum output requirements protect against excessive slippage Flash loans eliminate the need for upfront borrowing capital Position Health: Ensure the final position maintains a healthy collateralization ratio based on Aave V3's risk parameters for WETH/USDC. ETH Value Attachment: The {value: USER_AMOUNT} ensures the user's ETH is sent with the transaction for the initial collateral contribution. © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 09:39:16 "},{"url":"api/margin/close.html","title":"Close","level":"1.7.2.5.2","keywords":[],"body":"Close Operation (Withdraw & Repay) This section provides a detailed guide for implementing the close operation, which allows users to exit leveraged positions efficiently. Overview The close operation enables users to exit a leveraged position by: Withdrawing collateral assets Swapping the withdrawn assets for the debt token Repaying the outstanding debt Refunding any excess assets to the user This process maintains capital efficiency by executing all operations within a single transaction using a flash loan wrapper. Example Scenario We'll demonstrate how to switch debt in a leveraged position on Aave V3 without de-leveraging. Our example: Initial Position: 3 WETH collateral with 8,000 USDC debt Operation: Withdraw ~2 WETH, swap to USDC, repay debt Flash Loan Provider: Morpho Blue (optimal for Ethereum and Base) Swap Provider: 1inch Aggregation Router Important: The caller must ensure the swap is quoted to receive at least the full debt amount. Otherwise, the transaction will fail. Implementation Constants and Setup Define the necessary addresses and amounts for the operation: // Core parameters uint256 USER_AMOUNT = 2.0e18; // Amount of WETH to swap // Protocol addresses address CALL_FORWARDER = 0xfCa1154C643C32638AEe9a43eeE7f377f515c801; // Default forwarder IComposer composer = IComposer(0x...); // 1delta composer // Aave V3 addresses address AAVE_V3_POOL = address(0x...); address AAVE_V3_USDC_V_TOKEN = address(0x...); // Variable debt token address AAVE_V3_A_TOKEN_WETH = address(0x...); // Collateral aToken // External protocols address oneInchAggregationRouter = address(0x111...); // Swap router address MORPHO_BLUE = address(0xbbb...); // Flash loan provider Step 1: Repay Operation Configure the repayment of USDC debt to Aave V3. Setting the amount to 0 ensures we repay the minimum of received funds and outstanding debt. bytes memory repay = abi.encodePacked( uint8(ComposerCommands.LENDING), uint8(LenderOps.REPAY), uint16(LenderIds.UP_TO_AAVE_V3 - 1), // Aave V3 identifier address(USDC), // Asset to repay uint128(0), // 0 = use all available funds address(user), // Beneficiary of the repayment uint8(2), // Variable rate mode address(AAVE_V3_USDC_V_TOKEN), // Variable debt token address(AAVE_V3_POOL) // Pool address ); // Safety sweep for excess funds bytes memory transferToUser = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.SWEEP), address(USDC), address(user), uint128(0) // Transfer any remaining balance ); // Combine operations bytes memory repayOperation = abi.encodePacked(repay, transferToUser); Step 2: Withdraw Operation Withdraw collateral and distribute it between the swap forwarder and user. This approach eliminates an extra transfer step and ensures no dust remains. // Withdraw entire collateral balance bytes memory withdraw = abi.encodePacked( uint8(ComposerCommands.LENDING), uint8(LenderOps.WITHDRAW), uint16(LenderIds.UP_TO_AAVE_V3 - 1), address(WETH), // Collateral asset uint128(0), // 0 = withdraw all address(COMPOSER_ADDRESS), // Initial receiver for splitting address(AAVE_V3_A_TOKEN_WETH), // aToken address address(AAVE_V3_POOL) ); // Transfer swap amount to forwarder bytes memory transferToForwarder = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.SWEEP), address(WETH), address(CALL_FORWARDER), uint128(USER_AMOUNT) // Exact amount for swap ); // Transfer remainder to user bytes memory transferToUser = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.SWEEP), address(WETH), address(user), uint128(0) // Transfer remaining balance ); // Combine operations bytes memory withdrawOperation = abi.encodePacked( withdraw, transferToForwarder, transferToUser ); Step 3: Configure Approvals Set up one-time approvals for all protocols. The composer automatically approves maximum amounts, and subsequent calls skip redundant approvals to save gas. // Approve Aave V3 for USDC repayment bytes memory approvePool = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.APPROVE), address(USDC), address(AAVE_V3_POOL) ); // Approve Morpho for WETH flash loan (uses transferFrom) bytes memory approveMorpho = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.APPROVE), address(WETH), address(MORPHO_BLUE) ); Step 4: Meta Swap Configuration Set up the swap operation through the forwarder. This follows the pattern described in the External Call documentation, but skips manual transfers since funds are already positioned. // Configure 1inch router call bytes memory callForwarderCall = abi.encodePacked( uint8(ComposerCommands.EXT_CALL), address(oneInchAggregationRouter), uint128(0), // No ETH value for ERC20 swap uint16(data.length), data // 1inch swap calldata ); // Approve 1inch to spend WETH bytes memory approve1inch = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.APPROVE), address(WETH), address(oneInchAggregationRouter) ); // Set slippage protection (expecting 8,000 USDC) uint256 amountExpected = 8000.0e6; bytes memory sweepAndCheckSlippage = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.SWEEP), address(USDC), address(receiver), uint8(SweepType.AMOUNT), amountExpected // Revert if less than expected ); // Combine swap operations callForwarderCall = abi.encodePacked( approve1inch, callForwarderCall, sweepAndCheckSlippage ); // Wrap in composer call bytes memory metaSwap = abi.encodePacked( uint8(ComposerCommands.EXT_CALL), address(CALL_FORWARDER), // Must use forwarder at composer level uint128(0), uint16(callForwarderCall.length), callForwarderCall ); Step 5: Assemble Complete Transaction Combine all operations within a flash loan wrapper for atomic execution: uint128 amount = uint128(2.0e18); // Flash loan amount (2 WETH) // Inner operations: swap → repay → withdraw bytes memory innerOperation = abi.encodePacked( metaSwap, repayOperation, withdrawOperation ); // Wrap in flash loan bytes memory flashLoan = abi.encodePacked( uint8(ComposerCommands.FLASH_LOAN), uint8(FlashLoanIds.MORPHO_BLUE), address(WETH), address(MORPHO_BLUE), amount, uint16(innerOperation.length + 1), uint8(0), // Morpho Blue pool ID 0 innerOperation ); // Place approvals outside flash loan callback for gas optimization bytes memory composerOps = abi.encodePacked( approvePool, approveMorpho, flashLoan ); // Execute the complete operation composer.deltaCompose(composerOps); Key Considerations Permissions: Ensure ERC20(AAVE_V3_A_TOKEN_WETH).approve(...) is called before execution Slippage Protection: Always set minimum expected amounts to prevent unfavorable swaps Gas Optimization: Keep operations outside the flash loan callback when possible Error Handling: The transaction will revert if: Insufficient collateral to withdraw Swap returns less than debt amount Flash loan cannot be repaid Related Documentation Flash Loan Operations External Call Patterns Approval Management© 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 09:39:06 "},{"url":"api/margin/collateral-swap.html","title":"Collateral Swap","level":"1.7.2.5.3","keywords":[],"body":"Collateral Swap (Withdraw & Deposit) This guide covers collateral swaps, which allow users to exchange their collateral assets without closing positions or repaying debt. Overview Collateral swaps differ from leverage operations in one key way: you can withdraw your entire collateral balance. Since collateral balances change with each block due to interest accrual, the exact amount isn't always predictable when querying off-chain. This creates challenges when working with swap aggregators, which typically require exact input amounts for quotes. Example Scenario We'll demonstrate switching collateral on Aave V3 from WETH to USDT while maintaining a leveraged position. The process involves: Withdrawing WETH collateral Swapping WETH to USDT via 1inch Depositing USDT as new collateral We'll wrap this entire sequence in a Flash Loan using Morpho Blue as the flash loan provider. Starting Position: Collateral: 3 WETH Debt: 8,000 USDC Target: Convert 3 WETH to 12,000 USDT as new collateral Constants // The collateral amount to exchange uint256 USER_AMOUNT = 3.0e18; // Default forwarder address address CALL_FORWARDER = 0xfCa1154C643C32638AEe9a43eeE7f377f515c801; // 1Delta composer IComposer composer = IComposer(0x...); // Aave V3 pool address address AAVE_V3_POOL = address(0x...); // Aave V3 WETH collateral token address AAVE_V3_A_TOKEN_WETH = address(0x...); // 1inch aggregation router address oneInchAggregationRouter = address(0x111...); // Morpho Blue flash loan source address MORPHO_BLUE = address(0xbbb...); Operation Sequence 1. Deposit New Collateral After receiving USDT from the swap, we deposit it into Aave V3. Setting the amount to 0 deposits whatever USDT balance the contract holds. Important: Ensure all required approvals are granted beforehand (see Approvals section). bytes memory deposit = abi.encodePacked( uint8(ComposerCommands.LENDING), uint8(LenderOps.DEPOSIT), uint16(LenderIds.UP_TO_AAVE_V3 - 1), // Aave V3 identifier address(USDT), // Asset to deposit uint128(0), // 0 = deposit full contract balance address(user), // Deposit recipient address(AAVE_V3_POOL) // Aave V3 pool address ); 2. Withdraw Original Collateral We withdraw the entire WETH collateral balance and split it between the swap operation and any remainder for the user. bytes memory withdraw = abi.encodePacked( uint8(ComposerCommands.LENDING), uint8(LenderOps.WITHDRAW), uint16(LenderIds.UP_TO_AAVE_V3 - 1), // Aave V3 identifier address(WETH), // Asset to withdraw uint128(0), // 0 = withdraw full balance address(COMPOSER_ADDRESS), // Temporary recipient for splitting address(AAVE_V3_A_TOKEN_WETH), // Collateral token address address(AAVE_V3_POOL) // Aave V3 pool address ); // Send exact swap amount to forwarder bytes memory transferToForwarder = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.SWEEP), address(WETH), // Asset to transfer address(CALL_FORWARDER), // Recipient (swap forwarder) uint128(USER_AMOUNT) // Exact quoted amount ); // Send any remainder to user bytes memory transferToUser = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.SWEEP), address(WETH), // Asset to transfer address(user), // Recipient uint128(0) // Send remaining balance ); // Combine all withdrawal operations withdraw = abi.encodePacked( withdraw, transferToForwarder, transferToUser ); 3. Approvals Required approvals for the operation to succeed: // Approve Aave V3 pool to spend USDT for deposit bytes memory approvePool = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.APPROVE), address(USDT), // Asset to approve address(AAVE_V3_POOL) // Spender ); // Approve Morpho Blue to pull WETH for flash loan repayment bytes memory approveMorpho = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.APPROVE), address(WETH), // Asset to approve address(MORPHO_BLUE) // Spender ); 4. Meta Swap Configuration The swap operation uses the external call pattern described in External Call: // Configure the forwarder call to 1inch bytes memory callForwarderCall = abi.encodePacked( uint8(ComposerCommands.EXT_CALL), address(oneInchAggregationRouter), // Target contract uint128(0), // No ETH value for ERC20 swap uint16(data.length), // Call data length data // 1inch swap call data ); // Approve 1inch to spend WETH bytes memory approve1inch = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.APPROVE), address(WETH), // Asset to approve address(oneInchAggregationRouter) // Spender ); // Verify minimum output and transfer to recipient uint256 amountExpected = 12000.0e6; // Expected USDT amount (6 decimals) bytes memory sweepAndCheckSlippage = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.SWEEP), address(USDT), // Asset to sweep address(receiver), // Final recipient uint8(SweepType.AMOUNT), amountExpected // Minimum required amount ); // Combine forwarder operations callForwarderCall = abi.encodePacked( approve1inch, callForwarderCall, sweepAndCheckSlippage ); // Create meta swap call through forwarder bytes memory metaSwap = abi.encodePacked( uint8(ComposerCommands.EXT_CALL), callForwarderAddress, // Forwarder contract uint128(0), // No ETH value uint16(callForwarderCall.length), // Call data length callForwarderCall // Forwarder operations ); Complete Operation Assembly Putting it all together with the flash loan wrapper: uint128 flashLoanAmount = uint128(3.0e18); // Amount to flash loan // Inner operations executed within flash loan callback bytes memory innerOperation = abi.encodePacked( withdraw, // Withdraw WETH collateral metaSwap, // Swap WETH to USDT deposit // Deposit USDT as new collateral ); // Flash loan wrapper bytes memory flashLoan = abi.encodePacked( uint8(ComposerCommands.FLASH_LOAN), uint8(FlashLoanIds.MORPHO_BLUE), address(WETH), // Flash loan asset address(MORPHO_BLUE), // Flash loan provider flashLoanAmount, // Flash loan amount uint16(innerOperation.length + 1), // Callback data length uint8(0), // Morpho Blue pool ID innerOperation // Operations to execute ); // Complete operation sequence bytes memory composerOps = abi.encodePacked( approvePool, // Pre-approve Aave pool approveMorpho, // Pre-approve Morpho Blue flashLoan // Execute flash loan with inner operations ); // Execute the complete collateral swap composer.deltaCompose(composerOps); Key Considerations Exact Amounts: When withdrawing the entire collateral balance, split transfers ensure the swap gets exactly the quoted amount while the user receives any remainder. Permissions: The operation requires prior approval of the WETH collateral token: IERC20(AAVE_V3_A_TOKEN_WETH).approve(composer, type(uint256).max) Slippage Protection: The sweep operation with SweepType.AMOUNT ensures you receive at least the expected minimum output from the swap. Gas Optimization: Using the forwarder pattern eliminates unnecessary token transfers between operations. © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 09:39:10 "},{"url":"api/margin/debt-swap.html","title":"Debt Swap","level":"1.7.2.5.4","keywords":[],"body":"Debt Swap (Borrow & Repay) This guide covers debt swaps, which allow users to change their debt composition without closing positions or affecting collateral balances. Overview Debt swaps involve borrowing a new asset, swapping it for the currency needed to repay existing debt, then repaying the original debt. This maintains your leveraged position while switching between debt assets (e.g., from USDC debt to USDT debt). The entire operation is wrapped in a flash loan to ensure atomicity and capital efficiency. Example Scenario We'll demonstrate switching debt on Aave V3 from USDC to USDT while maintaining the same collateral position. The process involves: Flash loan USDT Swap USDT to USDC via 1inch Repay existing USDC debt Borrow new USDT debt to repay flash loan Refund any excess to user Starting Position: Collateral: 3 WETH Debt: 8,000 USDC Target: Same collateral: 3 WETH New debt: 8,000 USDT We'll use Morpho Blue as our flash loan provider for optimal rates. Constants // The debt amount to swap uint256 DEBT_AMOUNT = 8000.0e6; // Default forwarder address address CALL_FORWARDER = 0xfCa1154C643C32638AEe9a43eeE7f377f515c801; // 1Delta composer IComposer composer = IComposer(0x...); // Aave V3 pool address address AAVE_V3_POOL = address(0x...); // Aave V3 variable debt tokens address AAVE_V3_USDC_V_TOKEN = address(0x...); address AAVE_V3_USDT_V_TOKEN = address(0x...); // 1inch aggregation router address oneInchAggregationRouter = address(0x111...); // Morpho Blue flash loan source address MORPHO_BLUE = address(0xbbb...); Operation Sequence 1. Repay Existing Debt After receiving USDC from the swap, we repay the existing USDC debt. Setting amount to 0 repays up to the contract's balance or total debt, whichever is smaller. Important: Ensure all required approvals are granted beforehand (see Approvals section). bytes memory repay = abi.encodePacked( uint8(ComposerCommands.LENDING), uint8(LenderOps.REPAY), uint16(LenderIds.UP_TO_AAVE_V3 - 1), // Aave V3 identifier address(USDC), // Asset to repay uint128(0), // 0 = repay up to balance/debt address(user), // Debt owner uint8(2), // Variable rate mode address(AAVE_V3_USDC_V_TOKEN), // Variable debt token address(AAVE_V3_POOL) // Aave V3 pool address ); // Refund any excess USDC to user bytes memory transferToUser = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.SWEEP), address(USDC), // Asset to transfer address(user), // Recipient uint128(0) // Send remaining balance ); // Combine repay with refund bytes memory repayAndRefund = abi.encodePacked( repay, transferToUser ); 2. Borrow New Debt We borrow exactly the flash loan amount (plus any fees) in USDT. The borrowed funds go directly to the forwarder to minimize transfers. bytes memory borrow = abi.encodePacked( uint8(ComposerCommands.LENDING), uint8(LenderOps.BORROW), uint16(LenderIds.UP_TO_AAVE_V3 - 1), // Aave V3 identifier address(USDT), // Asset to borrow uint128(DEBT_AMOUNT), // Flash loan repayment amount address(CALL_FORWARDER), // Send directly to forwarder uint8(2), // Variable rate mode address(AAVE_V3_POOL) // Aave V3 pool address ); 3. Approvals Required approvals for the operation to succeed: // Approve Aave V3 pool to spend USDC for debt repayment bytes memory approvePool = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.APPROVE), address(USDC), // Asset to approve address(AAVE_V3_POOL) // Spender ); // Approve Morpho Blue to pull USDT for flash loan repayment bytes memory approveMorpho = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.APPROVE), address(USDT), // Asset to approve address(MORPHO_BLUE) // Spender ); 4. Meta Swap Configuration The swap operation converts borrowed USDT to USDC for debt repayment. Since funds are already at the forwarder from the borrow operation, we skip manual transfers. // Configure the forwarder call to 1inch bytes memory callForwarderCall = abi.encodePacked( uint8(ComposerCommands.EXT_CALL), address(oneInchAggregationRouter), // Target contract uint128(0), // No ETH value for ERC20 swap uint16(data.length), // Call data length data // 1inch swap call data ); // Approve 1inch to spend USDT bytes memory approve1inch = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.APPROVE), address(USDT), // Asset to approve address(oneInchAggregationRouter) // Spender ); // Verify minimum output and transfer to composer uint256 amountExpected = 8000.0e6; // Expected USDC amount bytes memory sweepAndCheckSlippage = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.SWEEP), address(USDC), // Asset to sweep address(composer), // Send to composer for repay uint8(SweepType.AMOUNT), amountExpected // Minimum required amount ); // Combine forwarder operations callForwarderCall = abi.encodePacked( approve1inch, callForwarderCall, sweepAndCheckSlippage ); // Create meta swap call through forwarder bytes memory metaSwap = abi.encodePacked( uint8(ComposerCommands.EXT_CALL), address(CALL_FORWARDER), // Forwarder contract uint128(0), // No ETH value uint16(callForwarderCall.length), // Call data length callForwarderCall // Forwarder operations ); Complete Operation Assembly Putting it all together with the flash loan wrapper: uint128 flashLoanAmount = uint128(DEBT_AMOUNT); // Amount to flash loan // Inner operations executed within flash loan callback bytes memory innerOperation = abi.encodePacked( borrow, // Borrow USDT and send to forwarder metaSwap, // Swap USDT to USDC via forwarder repayAndRefund // Repay USDC debt and refund excess ); // Flash loan wrapper bytes memory flashLoan = abi.encodePacked( uint8(ComposerCommands.FLASH_LOAN), uint8(FlashLoanIds.MORPHO_BLUE), address(USDT), // Flash loan asset address(MORPHO_BLUE), // Flash loan provider flashLoanAmount, // Flash loan amount uint16(innerOperation.length + 1), // Callback data length uint8(0), // Morpho Blue pool ID innerOperation // Operations to execute ); // Complete operation sequence bytes memory composerOps = abi.encodePacked( approvePool, // Pre-approve Aave pool for USDC approveMorpho, // Pre-approve Morpho Blue for USDT flashLoan // Execute flash loan with inner operations ); // Execute the complete debt swap composer.deltaCompose(composerOps); Key Considerations Debt Delegation: The operation requires prior debt delegation approval: IDebtToken(AAVE_V3_USDT_V_TOKEN).approveDelegation(composer, type(uint256).max) Flash Loan Fees: The borrow amount must account for any flash loan fees to ensure complete repayment. Slippage Protection: The sweep operation with SweepType.AMOUNT ensures you receive sufficient USDC to repay the debt. Gas Optimization: Approvals are placed outside the flash loan callback to reduce callback data size Direct transfers to the forwarder eliminate unnecessary token movements One-time approvals with maximum amounts reduce future gas costs Atomic Execution: The entire operation succeeds or fails as one transaction, preventing partial execution risks. Excess Handling: Any excess USDC from the swap is automatically refunded to the user, ensuring no funds are stuck. © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 09:39:13 "},{"url":"api/margin/migration.html","title":"Migration","level":"1.7.2.5.5","keywords":[],"body":"Position Migration Position migrations involve moving a leveraged position from one lending protocol to another without changing the underlying assets or requiring swaps. Let's demonstrate migrating an Aave V3 position to a Compound V3 position while maintaining the same collateral and debt composition. Migration Strategy The execution combines elements of both leverage and close operations: Flash loan the debt asset from the Aave V3 position Repay the Aave V3 debt completely Withdraw the Aave V3 collateral Deposit collateral into Compound V3 Borrow from Compound V3 to cover flash loan repayment Repay the flash loan with borrowed funds Refund any leftover dust to the user Example Scenario Starting Position (Aave V3): Collateral: 3 WETH Debt: 8,000 USDC Target Position (Compound V3): Collateral: 3 WETH Debt: 8,000 USDC Constants // Flash loan amount (slightly higher than debt to ensure full repayment) uint256 FLASH_LOAN_AMOUNT = 8000.1e6; // 8,000.1 USDC (0.1 USDC buffer) // Default forwarder address address CALL_FORWARDER = 0xfCa1154C643C32638AEe9a43eeE7f377f515c801; // 1Delta composer IComposer composer = IComposer(0x...); // Protocol addresses address AAVE_V3_POOL = address(0x...); address COMPOUND_V3_COMET = address(0x...); // USDC market comet address AAVE_V3_A_TOKEN_WETH = address(0x...); address AAVE_V3_USDC_V_TOKEN = address(0x...); // Flash loan source address MORPHO_BLUE = address(0xbbb...); // Asset addresses address WETH = address(0xC02...); address USDC = address(0xA0b...); Operation Sequence 1. Repay Aave V3 Debt Use the flash-loaned USDC to completely repay the existing Aave V3 debt. Using amount=0xffffffffffffffffffffffffffff ensures we repay the minimum of contract balance and actual debt. bytes memory repayAave = abi.encodePacked( uint8(ComposerCommands.LENDING), uint8(LenderOps.REPAY), uint16(LenderIds.UP_TO_AAVE_V3 - 1), // Aave V3 identifier address(USDC), // Asset to repay uint128(0xffffffffffffffffffffffffffff), // Repay full debt or balance address(user), // Debt owner uint8(2), // Variable rate mode address(AAVE_V3_USDC_V_TOKEN), // Variable debt token address(AAVE_V3_POOL) // Aave V3 pool ); 2. Withdraw Aave V3 Collateral Withdraw the entire WETH collateral from Aave V3. The collateral goes directly to the composer for the next operation. bytes memory withdrawAave = abi.encodePacked( uint8(ComposerCommands.LENDING), uint8(LenderOps.WITHDRAW), uint16(LenderIds.UP_TO_AAVE_V3 - 1), // Aave V3 identifier address(WETH), // Asset to withdraw uint128(0xffffffffffffffffffffffffffff), // Withdraw full balance address(composer), // Temporary recipient address(AAVE_V3_A_TOKEN_WETH), // Collateral token address(AAVE_V3_POOL) // Aave V3 pool ); 3. Deposit to Compound V3 Deposit the withdrawn WETH collateral into Compound V3. Using amount=0 deposits the contract's entire WETH balance. bytes memory depositCompound = abi.encodePacked( uint8(ComposerCommands.LENDING), uint8(LenderOps.DEPOSIT), uint16(LenderIds.UP_TO_COMPOUND_V3 - 1), // Compound V3 identifier address(WETH), // Asset to deposit uint128(0), // Deposit entire balance address(user), // Deposit recipient address(COMPOUND_V3_COMET) // Compound V3 comet address ); 4. Borrow from Compound V3 Borrow enough USDC from Compound V3 to repay the flash loan plus any fees. bytes memory borrowCompound = abi.encodePacked( uint8(ComposerCommands.LENDING), uint8(LenderOps.BORROW), uint16(LenderIds.UP_TO_COMPOUND_V3 - 1), // Compound V3 identifier address(USDC), // Asset to borrow uint128(FLASH_LOAN_AMOUNT), // Exact flash loan repayment amount address(composer), // Temporary recipient address(COMPOUND_V3_COMET) // Compound V3 comet address ); 5. Refund Excess USDC Transfer any remaining USDC balance back to the user after flash loan repayment. bytes memory refundExcess = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.SWEEP), address(USDC), // Asset to sweep address(user), // Recipient uint128(0) // Send remaining balance ); 6. Required Approvals Set up all necessary approvals for the operation: // Approve Aave V3 pool to spend USDC for repayment bytes memory approveAavePool = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.APPROVE), address(USDC), address(AAVE_V3_POOL) ); // Approve Compound V3 comet to spend WETH for collateral deposit bytes memory approveCompoundComet = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.APPROVE), address(WETH), address(COMPOUND_V3_COMET) ); // Approve Morpho Blue for flash loan repayment bytes memory approveMorpho = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.APPROVE), address(USDC), address(MORPHO_BLUE) ); Complete Migration Assembly Putting it all together with the flash loan wrapper: // Inner operations executed within flash loan callback bytes memory innerOperation = abi.encodePacked( repayAave, // Repay existing Aave V3 debt withdrawAave, // Withdraw Aave V3 collateral depositCompound, // Deposit collateral to Compound V3 borrowCompound, // Borrow from Compound V3 to repay flash loan refundExcess // Refund any excess USDC to user ); // Flash loan wrapper bytes memory flashLoan = abi.encodePacked( uint8(ComposerCommands.FLASH_LOAN), uint8(FlashLoanIds.MORPHO_BLUE), address(USDC), // Flash loan asset address(MORPHO_BLUE), // Flash loan provider uint128(FLASH_LOAN_AMOUNT), // Flash loan amount with buffer uint16(innerOperation.length + 1), // Callback data length uint8(0), // Morpho Blue pool ID innerOperation // Operations to execute ); // Complete migration sequence bytes memory migrationOps = abi.encodePacked( approveAavePool, // Pre-approve Aave pool approveCompoundComet, // Pre-approve Compound comet approveMorpho, // Pre-approve Morpho Blue flashLoan // Execute migration with flash loan ); // Execute the complete position migration composer.deltaCompose(migrationOps); Key Considerations 1. Dust Management The borrow-repay process will leave dust since we must use a fixed flash loan amount larger than the exact Aave V3 debt to ensure complete repayment. The excess is automatically refunded to the user. 2. Flash Loan Buffer To ensure we can repay the flash loan completely, we borrow the Aave V3 debt amount plus a safety margin (e.g., 0.1 USDC buffer). This accounts for: Interest accrual between quote and execution Flash loan fees (if any) Rounding differences in debt calculations 3. Protocol Permissions The operation requires pre-approval on both protocols: Aave V3: Approve composer for collateral withdrawal: IERC20(AAVE_V3_A_TOKEN_WETH).approve(composer, type(uint256).max) Compound V3: Allow composer for operations: IComet(COMPOUND_V3_COMET).allow(composer, true) 4. Market Compatibility Ensure the target Compound V3 market accepts the same collateral asset and allows borrowing the same debt asset. Compound V3 markets are isolated and each supports specific asset combinations. 5. Risk Parameter Changes Different protocols have different: Loan-to-value ratios Liquidation thresholds Interest rate models Verify the position remains healthy after migration and adjust if necessary. 6. Atomic Execution The entire migration is atomic - either all steps succeed or the transaction reverts, ensuring no partial migrations that could leave positions in an inconsistent state. 7. Gas Optimization All approvals are performed outside the flash loan callback Using amount=0 and max values reduces the need for exact balance calculations Direct transfers between operations minimize intermediate steps© 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-09-03 06:14:50 "}]