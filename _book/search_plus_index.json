[{"url":"./","title":"Introduction","level":"1.1","keywords":[],"body":"Welcome to the 1delta Docs! 1delta is a decentralized margin aggregator service that allows users to directly build margin positions using established DEXs and lending protocols. Our objective is to bring a universal aggregator service (comparable to Interactive Brokers in CeFi) to EVMs. Unbound by our own liquidity, we do not have the same limitations that comparable decentralized aggregators experience. Our goal is to partner with and aggregate established protocols in the space and not to directly compete against them. At the moment, crypto traders are limited in the options they have for building leverage while trading. If they choose to use money market protocols for building margin positions they will face a multi-step process that spans multiple dApps, is error-prone, and has low visibility. Existing aggregator/derivatives platforms have been the go-to solution for leveraged trading, however, they come with a steep tradeoff. While centralized players like FTX have failed users by misusing their funds, decentralized platforms like dYdX or GMX are required to provide both lending and trading liquidity often resulting in poor trading performance. Our vision is to bring fully-featured, decentralized aggregator services to EVMs. This includes Single-click margin trading (opening, closing positions, debt- and collateral swaps) Connecting established DEXs with established lending protocols to allow our users to access top-notch trading performance and highly competitive deposit and borrow rates Seamless UX and visibility - easy risk management through risk parameter displays and single-click self-liquidations Full transparency - Users hold the lending protocol balances themselves and can always see and access their raw balances with the lender Lending protocols have been less accessible to traders who are looking for a fully-featured aggregator. With 1delta, we hope to open the door for these traders to take advantage of the strong liquidity and attractive rates on large lending protocols without sacrificing the tools they have come to expect while trading.© 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-07 21:20:21 "},{"url":"margin-aggregation.html","title":"Margin Aggregation","level":"1.2","keywords":[],"body":"Margin Aggregation Margin Trading In Crypto Margin trading for cryptocurrencies is a financial strategy that enables investors to trade digital assets like Bitcoin, Ethereum, and other altcoins using borrowed funds from a broker or exchange. This approach allows traders to increase their purchasing power and enhance their profit potential by leveraging their existing capital. However, it's essential to remember that margin trading also entails higher risks and can lead to significant losses if the market moves against the trader's position. In cryptocurrency margin trading, investors can access leverage, which is essentially a multiplier that amplifies the trader's capital. For example, if a trader uses 5x leverage, a $1,000 investment would provide them with $5,000 worth of purchasing power in the market. This increased exposure can lead to substantial gains if the market moves in their favor, but it can also magnify losses if the market goes against them. To engage in margin trading, traders are required to deposit an initial margin (or collateral) into a lending protocol. This collateral serves as a guarantee for the borrowed funds and is calculated as a percentage of the total position value. Different lenders may have different margin requirements, and traders should be aware of the specific policies of their chosen platform. When margin trading cryptocurrencies, it's crucial to understand the concept of liquidation. Liquidation occurs when the market moves against a trader's position to the point where their collateral is no longer sufficient to cover their losses. Lenders usually measure this using the health factor. In such a case, the health factor drops below 1 and the wallet will be flagged for liquidation, allowing another actor to close part of the position to recover the borrowed funds. In summary, margin trading for cryptocurrencies is a high-risk, high-reward trading strategy that can lead to significant profits or losses, depending on market movements. It's best suited for experienced traders who have a solid understanding of market dynamics and can effectively manage risk. Margin Trading In DeFi To open margin positions, users can manually loop through the following steps if they want to open an ETH-long position with 4x leverage. Supply initial collateral in ETH worth $1,000 Borrow $800 worth of USDC (80% of %1,000) Swap to ETH and supply again - This will give us another $640 (80% of $800) in borrowing capacity. We will now repeat this cycle until we obtained our target leverage. Borrow $640 (80% of $800), swap an supply Borrow $512 (80% of $640), swap an supply Borrow $409.6 (80% of $512), swap an supply Borrow $327.68 (80% of$409.6), swap an supply Borrow $262.144 (80% of$327.68), swap an supply Borrow $48.576 (the remaining amount to bring the total borrowed funds to $3,000) We see that building this leverage takes 22 transactions to complete as each sub-step in step 3. consists of 3 separate transactions. The following chart summarizes the general procedure. 1) A first USDT deposit is required for taking out a loan; 2) we can borrow WBTC to our wallet; 3) we swap WBTC to USDT on a DEX; 4) we deposit USDT to the lender; we repeat from step 2) until we reach the desired position size. Certainly, this cannot be the long-term solution to DeFi margin trading. 1delta uses unique methods and implementations that allow opening such positions in a maximum of 2 transactions, where the first one is just the initial supply of the collateral. How 1delta Automates The Flow We illustrate the example above using the 1delta protocol. Supply initial collateral in ETH worth $1,000 We use a flash swap and receive $3,000 of ETH and supply We supply the obtained ETH We can now borrow 80% of the $4,000 ($3,200) in USDC the we supplied, we borrow $3,000 We repay the swap pool with the obtained $3,000 in USDC All sub-steps in step 2. happen within the same transaction. As such, there is no more manual looping when trying to build a leveraged position when using lending protocols. The following chart summarizes the interactions with the lender. Illustration of a swap router architecture that can open positions (borrow and supply) with flash swaps or flash loans in only two steps. © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-07 21:20:21 "},{"url":"guide/overview.html","title":"Guide","level":"1.3","keywords":[],"body":"How To Use 1delta 1delta has a unique approach to margin trading. Our initial version combines the simplicity of a lending protocol interface with well versed swap interfaces that will help you with building any position with the lender. Selecting a Trade To be able to trade on margin, similar to most brokers, you have to deposit collateral first. This can be done through multiple channels - You can either do it directly with the lender (by using their own UI), or just click the \"Deposit\" button in the main panel. If you already have collateral with the lender, this step is skipped. The following overview illustrates the configurations you can set up with the main trade panel. The selections map to the trade types as follows. Single Collateral Position: Swap and deposit or withdraw and swap. Single Debt Position: Borrow and swap or swap and repay. Two Collateral Positions: Swap collateral positions. Two Debt Positions: Swap debt positions. One Collateral and one Debt Positions: Open a margin position (Borrow, swap and supply) or close one (withdraw collateral, swap and repay debt) Lender-Dependent Mechanics Dependent on which lender you want to trade with, the mechanics can vary Via UI Programmatically © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-07 21:40:15 "},{"url":"guide/frontend.html","title":"Frontend","level":"1.3.1","keywords":[],"body":"How to use 1delta's margin aggregator In this guide, we will outline the process of utilizing the 1delta margin trading implementation to manage lending positions within the AAVE lending protocol. Deposit / Withdraw / Borrow / Repay First-off, we support all basic lending interactions. These can be triggered in multiple ways. Through the main panel (only of you have no deposits) Using the tables undernath the chart with the \"My Wallet\" or \"Markets\" tabs Clicking the button will trigger a quick action panel that allows you to execute any transaction that you could execute with a lending protocol. The quick action panel allows you to execute all direct transactions with the lenders. The left hand side shows the general view, whereas the right hand side shows a configuration where the trader wants to execute a swap before depositing. On input, the bottom of the panel shows a post-transaction indication. The top button row allows you to pick the transactions while the currency dropdowns allow you to pick the currencies for the interaction. In the quick action panel, your wallet balance is always shown at the top, indicated by the wallet icon. If an additional transaction is required before the transfer, the UI will instruct you to either approve spending (in case of deposits, withdrawals and repayments) or approve borrow delegation. After execution, you will see your balance in the \"positions\"-tab in the table: The amount deposited will be display once the deposit transaction is confirmed. Open a margin position With collateral in place, we can now proceed to open a margin position by selecting a borrow currency at the top and a the collateral currency at the bottom. You also have to make sure that the \"open\" option is selected at the top. In our example, we want to sell the maximum amount MWNT possible given our collateral. This value is auto-selected when clicking on the MAX button. As a collateral, we select the currency that we deposited, USDC. The Account panel on the left hand side allows you to simulate the trade on your position by enabling the \"Simulation\" switch at the bottom. On the left hand side, the account panel simulates the user position post-trade. For the given trade on the right hand side, the APR rises by 103 percentage points, the assets and debt rise by about $17.50 and our leverage shoots up to 4.83x. A value can be typed into either panel. After entering a value, a trade will be calculated that leads to the best price. The button will be inactive if you are not allowed to execute the trade (e.g. if your selected trade is too large). Otherwise, a click on the button will trigger your wallet to approve the trade. If any sort of approval is required, the UI will show an approval button instead. Just approve the respective spending or delegation to be able to proceed with the trade. The balanes in the \"Positions\" tab swiftly update and we can see the result after executing the trade selected above: A borrow position with a lender is flagges as a \"Short\" position in 1delta, whereas collateral positions are \"Long\" positions. Swap debt or collateral With 1delta, we can effortlessly exchange our debt or collateral positions in just a single click. The \"Swap\"-option in the main panel enables a sub-selection with \"Collateral\" and \"Debt\" option. Collateral: Executing a collateral swap - a transactions where you can withdraw the top currency, swap it to the bottom currency and deposit it directly. An execution requires you to own the withdrawal currency, meaning that you can only execute a trade where the top amount is lower or equal your existing collateral No restrictions apply to the bottom panel Debt: Executing a debt swap - a transaction that borrows the top currency, swaps it to the bottom one and directly repays it. An execution requires you to hold a debt position in the bottom currency. No restriction to the top currency applies *Collateral- and debt swaps allow you to easily change your exposure in a single trade. In this screenshot, we see the 4.57 USDC obtained after a swap from 10 MNT. Closing a margin position Closing a position (withdraw, swap an repay) is similarly easy. The \"Close\" tab in top button row allows you to execute the following three interactions in one transaction: Withdraw one of your collaterals Trade the currency against another one Repay an outstanding loan You can either pick the maximum collateral amount to withdraw or the maximum debt amount to repay. Our implementation makes sure that no borrow dust will be left. Closing a position allows you to repay a debt position with ease. The simulations on the left hand side shows that our leverage and APR come down to the levels before the position was opened.© 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-07 21:20:21 "},{"url":"guide/programmatically.html","title":"Programmatically","level":"1.3.2","keywords":[],"body":"How to use 1delta's margin aggregator programmatically 1delta's smart contracts can be used via our Typescript SDK (which is also the one used for our UI). It is using out asset-registry package here. This package contains all lender data that is needed for on-chain actions (e.g. Aave lending tokens, Venus comptrollers etc.). The SDK automatically identifies a lender via the provided enum. Packages pnpm add @1delta/calldata-sdk @1delta/asset-registry // enums for operations import {QuickActionType, MarginTradeType} from \"@1delta/calldata-sdk\" // for direct lending actions import {ComposerDirectLending} from \"@1delta/calldata-sdk\" // margin operations import {ComposerMargin} from \"@1delta/calldata-sdk\" // enums import {Lender} from \"@1delta/asset-registry\" Example usage for depositing to Aave V3 Deposits assets to Aave. The caller needs to ensure that the contract has enough permissions (e.g. token.approve(...)) // --- Configuration for chain --- const chainId = \"10\" const composer = COMPOSER_PROXIES[chainId] // --- Asset and amount --- // Example: deposit 1000 USDC (1e9 = 1000 * 1e6 in smallest units) const input = 1_000_000_000n // 1e9 const depositAsset = { symbol: \"USDC\", name: \"USDC\", address: \"0x0b2c639c533813f4aa9d7837caf62653d097ff85\", chainId } // --- Caller account --- const account = \"0x...\" // --- Lender and action type --- const lender = Lender.AAVE_V3 const action = QuickActionType.Deposit // --- Operation parameters --- const operation = { params: { lender, amount: { currency: depositAsset, amount: input } }, receiver: account, // Caller deposits on their own behalf isAll: false, // Only used for withdraw & repay operations inIsNative: false, // If true, use native asset (ETH) to deposit — operation will wrap ETH outIsNative: false,// If true, unwraps output (e.g. withdraw WETH and unwrap to ETH) composerAddress: composer, permitData: undefined, // No permit used morphoParams: undefined, // No Morpho parameters useOverride: undefined // No custom Aave fork override } // --- Generate calldata and value for transaction --- const { calldata, value } = ComposerDirectLending.composeDirectMoneyMarketAction(operation) Example usage for opening a position on Aave V3 Open a position on Aave. The caller needs to ensure that the contract has enough permissions (e.g. via debtToken.approveDelegation(...)) // Example: Opening a short position on 1 WETH using USDC as collateral const chainId = \"10\" const composer = COMPOSER_PROXIES[chainId] // The caller's account address const account = \"0x...\" // Operation type const marginTradeType = \"Open\" // Intended input amount (in wei) const input = 1_000_000_000_000_000_000n // 1e18 // Assets const assetIn = { symbol: \"WETH\", name: \"WETH\", address: \"0x4200000000000000000000000000000000000006\", chainId } const assetOut = { symbol: \"USDC\", name: \"USDC\", address: \"0x0b2c639c533813f4aa9d7837caf62653d097ff85\", chainId } // Lender to use (refer to the `Lender` enum in asset-registry) const lender = Lender.AAVE_V3 // --- Step 1: Fetch flash liquidity --- // Example return value: // // [ // { // \"id\": 0, // \"name\": \"AAVE_V3\", // \"type\": 2, // \"source\": \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\", // \"fee\": \"5\", // \"availableRaw\": \"7742114549858607894570\", // \"available\": 7742.11454985861 // }, // ... // ] const assetLiquidities = await ( await fetch(`https://margin-data.1delta.io/flashloan-asset/10/0x4200000000000000000000000000000000000006`) ).json() // Pick the first source (ideally choose the lowest-fee source) const flashLoanSource = assetLiquidities[0] // Flash loan fee is used to adjust the quote input const flashFee = BigInt(flashLoanSource.fee) // --- Step 2: Fetch trade --- // With a 5 bps flash fee, we can calculate the adjusted input to borrow exactly 1 WETH: const amendedInput = (input * 10_000n) / (10_000n + flashFee) // Query the swap provider API // Important: Set the receiver to the composer contract const apiBody = { ..., amountIn: amendedInput, receiver: composer } const apiReturn = await ( await fetch(`https://www.quote.odos....`) ).json() // Get calldata from the API (varies by provider) const { calldata, target } = await ( await fetch(`https://www.assemble.odos....`) ).json() // --- Step 3: Prepare trade object for SDK --- const trade: GenericTrade = { tradeType: 0, // exact in inputAmount: { currency: assetIn, amount: amendedInput }, outputAmount: { currency: assetOut, amount: apiReturn.output }, // Output amount is unused in calldata target, // Call target approvalTarget: target, // Usually same as call target, may differ for some aggregators // Set to `true` if `apiBody` does not allow specifying a receiver sweepToReceiver: false, } const externalCall = { target, calldata, value: \"0\", // Default (only used for native asset as input) useSelfbalance: false, callForwarder: FORWARDER } const marginData = { marginTradeType, // STABLE is disabled for most Aave forks irModeIn: AaveInterestMode.VARIABLE, // Unused irModeOut: AaveInterestMode.NONE, lender, morphoParams: undefined, // No Morpho execution permitData: undefined // No permits in this example } // This returns a bytes string for the 1delta composer const composerOperation = ComposerMargin.createMarginFlashLoan({ trade, externalCall, marginData, maxIn: false, // Default (only for non-open operations) maxOut: false, // Default (only for non-open operations) composerOverride: composer, // Composer address flashInfoOverride: flashLoanSource // Flash loan source info }) // Note: Any composer operation can be prepended, e.g.: // // This is the calldata for the composer. // For example, `ComposerDirectLending.composeDirectMoneyMarketAction(...)` // could be used to generate a deposit calldata set, which can then be prepended: // // const depositAndOpen = encodePacked( // [\"bytes\", \"bytes\"], // [depositCalldata, composerOperation] // ) const contractCall = encodeFunctionData({ abi: composerAbi, functionName: \"deltaCompose\", args: [composerOperation] }) © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-10 20:15:01 "},{"url":"architecture/overview.html","title":"Architecture","level":"1.4","keywords":[],"body":"How is 1delta Built? Generally, lending protocols fall into two categories when trying to compose trades with them. First, we have protocols that allow a user to delegate borrows and withdrawals. This means that a user can approve that another contract can borrow using their collateral or withdraw collateral from their balances directly. This is very similar to the conventional ERC20 approval mechanism that allows this exact mechanic for regular transfers. This architecture allows an external contract to aggregate the position on the user's behalf - meaning that the contract can directly operate on the user's balance. Compound V3, Venus.io and AAVE V3 are protocols in this category. On the other hand, we have protocols that do not allow this type of delegation. In this case, users can create abstract account that will build the positions on their behalf. These abstract accounts are smart contracts that can only be operated by the user that created them. Compound V2 and most forks fall into this category. Delegation Architecture © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-07 21:33:39 "},{"url":"architecture/delegation.html","title":"Borrow Delegation","level":"1.4.1","keywords":[],"body":"Delegation Structure The architecture for protocols that allow delegated borrowing and withdrawals is provided as follows. In a first step, the user has to approve that the \"Broker contract\" can interact on their behalf. This has to be done if the user wants to execute transactions that include borrowing or withdrawals. If this is done, the contract can be handled similar to a Uniswap-type swap router. © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-07 21:20:21 "},{"url":"lenders/summary.html","title":"Lenders","level":"1.5","keywords":[],"body":"Lenders The following subsections describe the lenders and their specific parameters. Metrics© 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-07 21:20:21 "},{"url":"lenders/metrics.html","title":"Metrics","level":"1.5.1","keywords":[],"body":"Lending Metrics This section dives into the parameters that lenders use to manage their protocol. The following parameters are used by most of them, including Compound V2 & V3, Aave V1, V2 & V3 and all forks of them. General Parameters All lenders define in one or another form the following parameters: Note that the liquidation collateral factors are usually higher than the borrow collateral factors. Lenders in general allow opening positions at maximum LTV equal to the debt divided by borrow-adjusted collateral. Risk Metrics The collateral parameters and heath factor are calculated in the following manner: An account is flagged for liquidation if the health factor is below 1. Liquidation Price Liquidation prices in return are indicators as to how much a single asset price can move until an account get liquidated. This is done by setting the health factor to one and solving for the USD amount of the desired asset. The liquidation price for a long asset (indexed with k) can be calculated via assuming that the USD amount of asset k is dependent on all other given parameters as follows: Dividing the last amount by the collateral amount in question yields the liquidation price for a long position in asset k: For a short asset, we solve for the debt USD amount of asset k: Dividing the last amount by the debt amount in question yields the liquidation price for the short position in asset k: Same-asset positions Generally, the liquidation price in a specific asset assumes that the prices of all other assets are frozen. Certain lenders, however, allow borrowing and collateralizing the same asset at the same time. These lenders are Aave V3, Lendle, Compound V2 and all respective forks. For this case, we cannot use the conventional liquidation price, since for a long position with a borrow position of less than the collateral, the liquidation risk in this specific asset is non-existent. Generally, there are two cases for liquidation prices of asset k, in both we calculate the net exposure in the asset and apply it to the liquidation price: The collateral in the asset is higher than the debt Long liquidation price: For this case, we have to net the exposure in the single asset. In this case, we reduce all amounts by the debt amounts. Short liquidation price: Infinity, since there is no liquidation risk. The collateral in the asset is lower than the debt Long liquidation price: Zero, there is no long liquidation risk in this asset. Short liquidation price: For this case, we also have to net the exposure in the single asset. This means that we use the conventional liquidation price and reduce all amounts by the respective collatreral amount. Leverage The leverage is a good measure for exposure. It can be provided on an overall basis or just in the context of a single asset. The overall leverage is just the quotient of collateral and debt. The maximum leverage for a single asset is calculated using the collateral factor of the collateral asset. It is important to note that in this case, the maximum leverage for a single asset is dependent on the collateral assetn and its borrow collateral factor only. As such, measuring the leverage for the short asset only depends on the collateral used (in this case, it is usually a stablecoin). Certain lenders like Euler Finance use borrow factors to weight borrow positions differently, too. © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-07 21:20:21 "},{"url":"contract-addresses/summary.html","title":"Contract Addresses","level":"1.6","keywords":[],"body":"Contract Addresses These are the deployment addresses for the 1delta composer smart contracts. Composer contract Chain Address ARBITRUM_ONE 0x05f3f58716a88A52493Be45aA0871c55b3748f18 OP_MAINNET 0xCDef0A216fcEF809258aA4f341dB1A5aB296ea72 POLYGON_MAINNET 0xFd245e732b40b6BF2038e42b476bD06580585326 BASE 0xB7ea94340e65CC68d1274aE483dfBE593fD6f21e SONIC_MAINNET 0x8E24CfC19c6C00c524353CB8816f5f1c2F33c201 HEMI_NETWORK 0x79f4061BF049c5c6CAC6bfe2415c2460815F4ac7 TAIKO_ALETHIA 0x594cE4B82A81930cC637f1A59afdFb0D70054232 METIS_ANDROMEDA_MAINNET 0xCe434378adacC51d54312c872113D687Ac19B516 GNOSIS 0xcb6eb8df68153cebf60e1872273ef52075a5c297 AVALANCHE_C_CHAIN 0x8E24CfC19c6C00c524353CB8816f5f1c2F33c201 MODE 0x8E24CfC19c6C00c524353CB8816f5f1c2F33c201 SCROLL 0x8E24CfC19c6C00c524353CB8816f5f1c2F33c201 CORE_BLOCKCHAIN_MAINNET 0x816EBC5cb8A5651C902Cb06659907A93E574Db0B FANTOM_OPERA 0x816EBC5cb8A5651C902Cb06659907A93E574Db0B BNB_SMART_CHAIN_MAINNET 0x816EBC5cb8A5651C902Cb06659907A93E574Db0B MANTLE 0x5c019a146758287c614fe654caec1ba1caf05f4e LINEA 0x816EBC5cb8A5651C902Cb06659907A93E574Db0B BLAST 0x816EBC5cb8A5651C902Cb06659907A93E574Db0B KAIA_MAINNET 0x8E24CfC19c6C00c524353CB8816f5f1c2F33c201 SONEIUM 0x8E24CfC19c6C00c524353CB8816f5f1c2F33c201 HYPEREVM 0xcb6eb8df68153cebf60e1872273ef52075a5c297 UNICHAIN 0xcB6Eb8df68153cebF60E1872273Ef52075a5C297 KATANA 0x8E24CfC19c6C00c524353CB8816f5f1c2F33c201 Call forwarder contract Chain Address ALL CHAINS 0xfCa1154C643C32638AEe9a43eeE7f377f515c801 © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-10 20:03:06 "},{"url":"api/summary.html","title":"Contract API","level":"1.7","keywords":[],"body":"Contract Interfaces The following subsections describe the smart contract api for both the brokerage/aggregation contract. Entrypoint Operations Transfers External Call Lending Aave Compound V3 Flash Loans Margin© 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-10 19:55:45 "},{"url":"api/entrypoint.html","title":"Entrypoint","level":"1.7.1","keywords":[],"body":"1delta contract entrypoiny Our smart contract has a single call entrypoint for external calls. deltaCompose(bytes) is the trigger to call a batch operation in our composer contracts. Aside of approval & entry flags, the contract is stateless. The deltaCompose function consumes byte-encoded operations that are sequentially executed. The operations themselves are categorized via human-readable enum values as follows enum ComposerCommands { SWAPS; // swap paths EXT_CALL; // external calls (`deltaForwardCompose`) EXT_TRY_CALL; // external call with fallback (callForwarder only) LENDING; // any lending operation (deposit, borrow, withdraw, repay) TRANSFERS; // pulling, sending and approving PERMIT; // execute token or lender permit FLASH_LOAN; // execute flash loans on common targets ERC4626; // vault operations GEN_2025_SINGELTONS; // balancer V3 and Uniswap V4 operations BRIDGING; // bridge execution (callForwarder only) } To create an operation OPERATION with that has e.g. the following parameters Offset Length (bytes) Description 0 20 underlying address 20 16 amount uint128 36 20 receiver address 56 20 comet address the caller has to encode it as follows: bytes memory operation = abi.encodePacked( uint8(ComposerCommands.[OPERATION]), address(underlying), uint128(amount), address(receiver), address(comet) ) composer.deltaCompose(operation); It is designed so that the caller can always append any sort of operations. bytes memory operation = abi.encodePacked( operation0, // (as bytes memory) add another operation to the start uint8(ComposerCommands.[OPERATION]), // then just continue the next one address(underlying), uint128(amount), address(receiver), address(comet) ) composer.deltaCompose(operation); © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-10 18:24:33 "},{"url":"api/operations.html","title":"Operations","level":"1.7.2","keywords":[],"body":"Operation encoding Operations are produced by simply encoding them into a single bytes array. The following sections link to the specific operation creation code. Transfers External Call Lending Flash Loan Margin© 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-10 20:03:36 "},{"url":"api/transfers.html","title":"Transfers","level":"1.7.2.1","keywords":[],"body":"Transfers Lead type: ComposerCommands.TRANSFERS. The sub types are dcefined by the following enum: enum TransferIds { TRANSFER_FROM = 0, // pull funds from caller SWEEP = 1, // send funds from this contract UNWRAP_WNATIVE = 3, // unwrap PERMIT2_TRANSFER_FROM = 4, // permitTransfer APPROVE = 5, // approve target } To encode an operation, te caller has to append abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.[Operation]), ...params ) to the array of composer commands. TRANSFER_FROM Pull funds from the caller to a receiver address. Offset Length (bytes) Description 0 20 asset address 20 20 receiver address 40 16 amount uint128 If amount is 0, we pull asset.balanceOf(caller). SWEEP Pull funds from this contract to a provided address. Can be used to run slippage checks. enum SweepType { VALIDATE = 0, // check if `balanceOf(address(this) >= amount, if true, transfer it, if not, revert AMOUNT = 1 // transfer the amount without further checks } Offset Length (bytes) Description 0 20 asset address 20 20 receiver address 40 1 sweepType SweepType 41 16 amount uint128 Note that asset can be the zero address for native currency. To wrap the native currency to wrapped native, you can just use asset=address(0),receicer=wrappedNativeAddress. APPROVE Approve an asset - typically for a leder operation or external call. Offset Length (bytes) Description 0 20 token address 20 20 target address ERC20-Approve the target via token, always uses infitie approve, the approval is stored and skipped if already done in the past. UNWRAP Unwrap native asset and transfer if needed. Offset Length (bytes) Description 0 20 wrappedNativeAddress address 20 20 receiver address 40 1 sweepType SweepType 41 16 amount uint128 Note that we do not hard-code the wrapped native address as some chains have duplicate wnative implementations. PERMIT2_TRANSFER_FROM Execute a transfer via permit2. We only support the canonical Unsiwap permit2 at address 0x000000000022D473030F116dDEE9F6B43aC78BA3. Offset Length (bytes) Description 0 20 asset address 20 20 receiver address 40 16 amount uint128 © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-10 18:58:25 "},{"url":"api/external-call.html","title":"External Call","level":"1.7.2.2","keywords":[],"body":"External calls in the composer contracts To provide the caller with full flexibility, we allow them to call any arbitrary target indirectly via a callForwarder contract that has the onl entrypoint function deltaForwardCompose(bytes) The composer contract can call arbitrary targets with that fixed selector, whereas the callForwarder can call any target whith any selector (there are exceptions like the permit2 address and transferFrom selector) To facilitate an external call with data on target, one needs to pull caller funds (directly to callForwarder) execute ComposerCommands.EXT_CALL with the parameters on the callForwarder on the composer where the operation forwarded is also ComposerCommands.EXT_CALL with the provided data and target While this approach seems to be inefficient, it is necessary to prevent malicious callers to execute bad calldata on the composer contract (e.g. trying to execute transferFrom from a prior caller that approved the composer) The operation parameters for the composer are given as follows. Offset Length (bytes) Description 0 20 target address 20 16 value uint128 36 20 dataLength address 38 dataLength data address value is the native currency amount to attach. The value has a high bit that indicates whether to use the selfbalance To encode an operation, te caller has to append this data to the call. abi.encodePacked( uint8(ComposerCommands.EXT_CALL), target, uint128(value), uint16(data.length), data ); Note that for arbitrary calls, we need to use the callForwarder, then it looks like this. // this is the default forwarder address address callForwarderAddress = 0xfCa1154C643C32638AEe9a43eeE7f377f515c801; // create the call for the forwarder // the target can e.g. be the 1inch aggregation router bytes memory callForwarderCall = abi.encodePacked( uint8(ComposerCommands.EXT_CALL), target, uint128(value), uint16(data.length), data ); // prepare the composer call bytes memory composerCall = abi.encodePacked( uint8(ComposerCommands.EXT_CALL), callForwarderAddress, // it is important to use the forwarder on the composer level uint128(value), uint16(callForwarderCall.length), callForwarderCall ); It is important to note that the call for the forwarder needs to be prepared. Example: 1inch meta-aggregation Hrere we illustrate the creation of the call for a swap from USDC to WETH using 1inch. The following steps need to be executed: callForwarder calls create approve if needed create external call to router sweep funds to receiver and check slippage if desired composer calls transfer funds from caller to callForwarder execute external call through callForwarder The reason why we use the forwarder is to peserve the statelessness of the composer while still allowing calls to any target without requiring whiltelists. uint256 swapAmount = 4000.0e6; // this is the default forwarder address address callForwarderAddress = 0xfCa1154C643C32638AEe9a43eeE7f377f515c801; // create the call for the forwarder // the target can e.g. be the 1inch aggregation router bytes memory callForwarderCall = abi.encodePacked( uint8(ComposerCommands.EXT_CALL), address(oneInchAggregationRouter), uint128(0), // ERC20 has no value uint16(data.length), data ); // we need to approve the 1inch router on the callForwarder level // note that the approval is skipped if it was already done in the past bytes memory approve1inch = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.APPROVE), address(USDC), address(oneInchAggregationRouter) ); // expect to receive 1 WETH // revert if we receive less uint256 amountExpected = 1.0e18; // in case the aggregators does not transfer directly to the user bytes memory sweepAndCheckSlippage = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.SWEEP), address(WETH), address(receiver), // this is the receiver of the WETH uint8(SweepType.AMOUNT), amountExpected ); // combine the operations callForwarderCall = abi.encodePacked( approve1inch, callForwarderCall, sweepAndCheckSlippage ); // prepare the composer call // this executes callForwader.deltaForwardCompose(callForwarderCall) bytes memory composerCall = abi.encodePacked( uint8(ComposerCommands.EXT_CALL), callForwarderAddress, // it is important to use the forwarder on the composer level uint128(value), uint16(callForwarderCall.length), callForwarderCall ); // we need to make sure that teh callForwarder receives the funds directly bytes memory transferToForwarder = abi.encodePacked( uint8(ComposerCommands.TRANSFERS), uint8(TransferIds.TRANSFER_FROM), address(USDC), callForwarderAddress, uint128(swapAmount) ); // combine the call to the composer composerCall = abi.encodePacked( transferToForwarder, composerCall ); // execute the operations composer.deltaCompose(composerCall); © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-10 19:05:41 "},{"url":"api/lending.html","title":"Lending","level":"1.7.2.3","keywords":[],"body":"Lending Lead type: ComposerCommands.LENDING. The sub types are dcefined by the following enum: enum LenderOps { DEPOSIT = 0, // deposit (collateral) BORROW = 1, // borrow from lender REPAY = 2, // repay to lender WITHDRAW = 3, // withdraw from lender DEPOSIT_LENDING_TOKEN = 4, // deposit lending token (e.g. for Morpho Blue) WITHDRAW_LENDING_TOKEN = 5, // withdraw lending token (e.g. for Morpho Blue) } to the array of composer commands. We ecode lender types as follows: enum LenderIds { UP_TO_AAVE_V3 = 1000, UP_TO_AAVE_V2 = 2000, UP_TO_COMPOUND_V3 = 3000, UP_TO_COMPOUND_V2 = 4000, UP_TO_MORPHO = 5000, } To encode an operation, te caller has to append this data to the call. abi.encodePacked( uint8(ComposerCommands.LENDING), uint8(TransferIds.[Operation]), uint16(LenderIds.[Lender]) ...params ) Specific lenders Aave V2 & V3 & forks Compound V3 markets© 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-08 12:50:11 "},{"url":"api/lending/aave.html","title":"Aave","level":"1.7.2.3.1","keywords":[],"body":"Aave V2 & V3 & Forks Aave V2 and V3 behave very similar for all operations. The caller only needs to dustinguish them via LenderIds, the rest is handled by the contract logic. Deposit Deposit the underlying to the lender for the given pool. If amount=0, we use the contract balance via underlying.balanceOf(address(this)). This is recommended when executing this operation after a swap. Offset Length (bytes) Description 0 20 underlying address 20 16 amount uint128 36 20 receiver address 76 20 pool address Withdraw Withdraw for the lender. Note that this requires that the caller approved the composer to spend aToken on their behalf. If amount=0xffffffffffffffffffffffffffff, we read underlying.balanceOf(callerAddress) and withdraw the full balance without leaving dust. Offset Length (bytes) Description 0 20 underlying address 20 16 amount uint128 36 20 receiver address 76 20 aToken address 96 20 pool address Borrow Borrow from the lender. The prequisite is that the caller approved the composer contract to borrow on thei behalf via debtToken.approveDelegation(...). It is important that the mode is provided here, most Aave forks only support mode=2 (variable). If the selector withotu mode is used, one needs to set mode=0. Offset Length (bytes) Description 0 20 underlying address 20 16 amount uint128 36 20 receiver address 76 1 mode uint8 77 20 pool address Repay Repay to the lender. In this case, use amount=0 to repay underlying.balanceOf(address(this)), the contract balance, if amount=0xffffffffffffffffffffffffffff, repay the minimum of the contract balance and the caller debt. Offset Length (bytes) Description 0 20 underlying address 20 16 amount uint128 36 20 receiver address 76 1 mode uint8 77 20 debtToken address 97 20 pool address © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-08 10:21:20 "},{"url":"api/lending/compound-v3.html","title":"Compound V3","level":"1.7.2.3.2","keywords":[],"body":"Compound V3 markets All Compound V3 markets behave the same way. The market is specified by the comet parameter. The markets are isolated from each other and only one currency is borrowable. Deposit Deposit the underlying to the lender for the given pool. If amount=0, we use the contract balance via underlying.balanceOf(address(this)). This is recommended when executing this operation after a swap. Offset Length (bytes) Description 0 20 underlying address 20 16 amount uint128 36 20 receiver address 76 20 comet address Withdraw Withdraw for the lender. Note that this requires that the caller approved the composer to via comet.allow(...). If amount=0xffffffffffffffffffffffffffff, we read underlying.balanceOf(callerAddress) and withdraw the full balance without leaving dust. Offset Length (bytes) Description 0 20 underlying address 20 16 amount uint128 36 20 receiver address 76 1 isBase uint8 77 20 comet address You need to provide the isBase flag if you want to withdraw the base asset. The reason for this is that Compound V3 has diffrerent ways to compute balances for the base asset. Borrow Borrow from the lender. The prequisite is that the caller approved the composer contract to borrow on their behalf via comet.allow(...). Offset Length (bytes) Description 0 20 underlying address 20 16 amount uint128 36 20 receiver address 76 20 comet address Repay Repay to the lender. In this case, use amount=0 to repay underlying.balanceOf(address(this)), the contract balance, if amount=0xffffffffffffffffffffffffffff, repay the minimum of the contract balance and the caller debt. Offset Length (bytes) Description 0 20 underlying address 20 16 amount uint128 36 20 receiver address 76 20 comet address © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-08 13:03:56 "},{"url":"api/flash-loan.html","title":"Flash Loan","level":"1.7.2.4","keywords":[],"body":"Flash Loans Lead type: ComposerCommands.FLASH_LOAN. The sub types are dcefined by the following enum: enum FlashLoanIds { MORPHO = 0, // this is Morpho Blue BALANCER_V2 = 1, // covers the fork Swaap, too AAVE_V3 = 2, // covers many forks AAVE_V2 = 3, // covers many forks } to the array of composer commands. To encode an operation, te caller has to append this data to the call. abi.encodePacked( uint8(ComposerCommands.FLASH_LOAN), uint8(FlashLoanIds.[FlashLoanProvider]), ...params ) Alternative sources can be Uniswap V4 and Balancer V3. Thsese are triggered via the lead type: ComposerCommands.GEN_2025_SINGELTONS. We elaborate on these later. Specific lenders Aave V2 & V3 & forks Singletons© 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-08 13:40:10 "},{"url":"api/flash-loan/standardized-interface.html","title":"Standardized Interface","level":"1.7.2.4.1","keywords":[],"body":"Standardized flash loan interface. While flash loans implementations are nearly all the same, the explicit usage and interface vary. In this section we cover the flash laons provided by Balancer V2 and Swaap Aave V2 & V3 Morpho Blue Flash loan The following parameters need to be provided for Aave V2, V3 and Morpho Blue: Offset Length (bytes) Description 0 20 asset address 20 20 pool address 40 16 amount uint128 56 2 paramsLength + 1 uint16 58 1 poolId uint8 59 + paramsLength paramsLength params bytes (packed) The way how the end data is structured is based on the validation logic. Since flash loans use callbacks, we need poolId to validate that the callback was triggred by a trusted Aave or Morpho pool. params is a packed set of composer operations. Note that The composer re-enters itself here The caller address is forwarderd from the origninal call source The validation logic is hard-coded, as such, only a limited set of pools are allowed to be called. Some flash loan sources are DEXs - e.g. Balancer V2 - this means that swaps thorugh it are not possible any longer as the DEX is typically re-entrancy protected. This also applies to Uniswap V4. They can be used as follows for e.g. looping USDC in a Aaave type lender. // select 1M USDC uint128 amount = uint128(1000000.0e6); bytes memory innerOperation = abi.encodePacked( encodeDeposit(...,USDC, amount,...) // deposit USDC amount to lender encodeBorrow(...,USDC, amount,...) // borrow USDC amount from lender ) bytes memory operation = abi.encodePacked( uint8(ComposerCommands.FLASH_LOAN), // then just continue the next one uint8(FlashLoanIds.MORPHO_BLUE), USDC, MORPHO_BLUE_ADDRESS amount, uint16(innerOperation.length + 1), uint8(0), // the original morpho blue has poolId 0. innerOperation ) composer.deltaCompose(operation); © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-10 19:06:05 "},{"url":"api/margin/general.html","title":"Margin","level":"1.7.2.5","keywords":[],"body":"General Margin Operations We provide a sketch to execute general margin operations here. The Flow In general, assuming the caller has existing balances with the lender, there aer two major steps, the flash loan itself and the inner call We execute the flashLoan call with currency X and amount x Execute the Inner Calls swap x to currency Y and amount y put y into a lender to increase the credit line (e.g. deposit or repay) pull x from the lender (e.g. withdraw or borrow) Repay the flash loan with funds x Considerations Lending operations that take funds need approvals (see Transfers section for that) and sometimes need to unwrap the flash loaned amount to native. Lending operations that pull funds on the user's behalf need to be permissioned by the user. © 1delta https://1delta.io/Found an error in the docs? The source code can be found here. Please feel free to edit and contribute a merge requestModified at: 2025-08-10 19:16:08 "}]